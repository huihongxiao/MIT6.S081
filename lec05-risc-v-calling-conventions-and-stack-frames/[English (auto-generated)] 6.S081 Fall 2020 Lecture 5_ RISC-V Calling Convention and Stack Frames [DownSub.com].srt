1
00:00:01,280 --> 00:00:03,520
好

2
00:00:05,759 --> 00:00:08,000
大家听得到我在说什么吗

3
00:00:08,000 --> 00:00:11,040
学生：听得清

4
00:00:11,360 --> 00:00:12,679
非常好

5
00:00:12,679 --> 00:00:15,599
从哪里开始呢

6
00:00:15,599 --> 00:00:17,440
像上周课的开头我问你们关于util实验那样开始吧

7
00:00:17,440 --> 00:00:19,199
这回

8
00:00:19,199 --> 00:00:20,800
我想先问问你们关于syscall实验的事

9
00:00:20,800 --> 00:00:22,320
因为在上周四这个实验就已经截止了

10
00:00:22,320 --> 00:00:26,320
所以

11
00:00:26,320 --> 00:00:27,920
有人愿意来分享分享吗

12
00:00:27,920 --> 00:00:30,000
比如你在实验中发现的有趣的事

13
00:00:30,000 --> 00:00:31,439
或者是讨厌的bug

14
00:00:31,439 --> 00:00:33,120
又或者是你犯下的某个愚蠢的错误

15
00:00:33,120 --> 00:00:34,800
你可以分享任何有关于syscall实验的想法

16
00:00:34,800 --> 00:00:35,680
只要愿意分享

17
00:00:35,680 --> 00:00:39,760
那就是非常好的 (之后一部分为学生分享，比较难懂，可以跳过)

18
00:00:39,760 --> 00:00:40,960
（学生）不知道咋的

19
00:00:40,960 --> 00:00:44,320
（学生）我删除了fork中那个必须备份掩码的部分（copy over the mask 存疑？）

20
00:00:44,320 --> 00:00:46,399
（学生）然后我让它运行了

21
00:00:46,399 --> 00:00:47,760
（学生）然后我又改变了些别的地方

22
00:00:47,760 --> 00:00:50,239
（学生）然后我测试了一下

23
00:00:50,239 --> 00:00:51,840
我想你的音频可能断开了

24
00:00:51,840 --> 00:00:53,920
（学生）非常抱歉

25
00:00:53,920 --> 00:00:58,000
（学生）你能听到我说话吗

26
00:00:58,000 --> 00:01:02,079
我现在听到了  （学生）好的

27
00:01:02,079 --> 00:01:05,438
（学生）嗯好的

28
00:01:05,438 --> 00:01:06,080
（学生）不知道为啥

29
00:01:06,080 --> 00:01:09,760
（学生）我删除了掩码的备份（the copy of the mask存疑）

30
00:01:09,760 --> 00:01:11,920
（学生）然后我的fork就不起作用了

31
00:01:11,920 --> 00:01:12,880
（学生）我就在想为啥它不起作用了

32
00:01:12,880 --> 00:01:15,119
（学生）我花费了很长时间

33
00:01:15,119 --> 00:01:16,640
（学生）才弄明白我错在哪儿

34
00:01:16,640 --> 00:01:18,960
（学生）我意识到

35
00:01:18,960 --> 00:01:22,240
（学生）我只是不小心删除了那行代码

36
00:01:22,720 --> 00:01:24,479
有没有人听不到luca的声音？

37
00:01:24,479 --> 00:01:26,159
或者只是我这里的问题？

38
00:01:26,159 --> 00:01:28,560
（学生）我觉得是你那里的问题，我可以听到他说话

39
00:01:28,560 --> 00:01:30,799
好的

40
00:01:32,159 --> 00:01:41,840
看来是我这里的问题

41
00:01:56,240 --> 00:01:59,759
抱歉，现在应该好了

42
00:02:02,640 --> 00:02:06,399
（学生）现在你能听到我说话吗 （老师）可以 （学生）好的

43
00:02:06,399 --> 00:02:08,720
（学生）我还担心是我这里的问题

44
00:02:08,720 --> 00:02:09,919
不

45
00:02:09,919 --> 00:02:13,760
完全是我的问题

46
00:02:17,200 --> 00:02:19,440
非常好，

47
00:02:19,440 --> 00:02:20,720
有没有其他人愿意分享？

48
00:02:20,720 --> 00:02:23,520
关于syscall实验的都行

49
00:02:24,160 --> 00:02:26,959
实验中任何有趣的事情都可以分享

50
00:02:26,959 --> 00:02:27,520
这个实验

51
00:02:27,520 --> 00:02:29,120
是不是太可怕了

52
00:02:29,120 --> 00:02:31,200
你们是不是想把它从课程中去掉，再也不碰了

53
00:02:31,200 --> 00:02:36,080
（学生）我想要发言（此处翻译时译者十分迷惑）

54
00:02:36,080 --> 00:02:38,959
（学生）显然

55
00:02:38,959 --> 00:02:40,800
（学生）这些一般性的语句是顺序关联的

56
00:02:40,800 --> 00:02:44,720
（学生）额

57
00:02:44,720 --> 00:02:47,840
（学生）在对函数进行跟踪(trace)之前

58
00:02:47,840 --> 00:02:49,040
（学生）我对系统调用函数

59
00:02:49,040 --> 00:02:50,959
（学生）进行了大量的推演计算

60
00:02:50,959 --> 00:02:53,120
（学生）来确定是否真的需要进行跟踪(tracing)

61
00:02:53,120 --> 00:02:56,319
（学生）所有的系统调用都被正确地追踪到了

62
00:02:56,319 --> 00:02:59,519
（学生）除了trace调用

63
00:02:59,519 --> 00:03:02,159
（学生）我当时真的感到很困扰

64
00:03:02,159 --> 00:03:03,920
（学生）直到，大概是David吧

65
00:03:03,920 --> 00:03:05,040
（学生）他指出我应该

66
00:03:05,040 --> 00:03:06,800
（学生）在对函数进行跟踪(trace)之后

67
00:03:06,800 --> 00:03:10,720
（学生）再开始推演计算,就是这样

68
00:03:10,720 --> 00:03:14,080
我很高兴你可以

69
00:03:14,080 --> 00:03:15,280
察觉到这一点

70
00:03:15,280 --> 00:03:18,000
嗯，顺序确实很重要

71
00:03:18,000 --> 00:03:19,920
尤其对于页表来说

72
00:03:19,920 --> 00:03:20,879
我认为

73
00:03:20,879 --> 00:03:22,640
顺序同样重要

74
00:03:22,640 --> 00:03:24,000
在我们整个课程中也是

75
00:03:24,000 --> 00:03:25,440
注意事物的顺序

76
00:03:25,440 --> 00:03:28,000
这很重要

77
00:03:28,000 --> 00:03:29,680
在页表中

78
00:03:29,680 --> 00:03:31,760
最好不要重写其内容

79
00:03:31,760 --> 00:03:34,159
（学生）我也有一些问题

80
00:03:34,159 --> 00:03:34,879
（学生）关于这些问题

81
00:03:34,879 --> 00:03:38,400
（学生）我仍然感到困惑

82
00:03:38,400 --> 00:03:40,799
（学生）我的内核代码中

83
00:03:40,799 --> 00:03:42,879
（学生）有一大堆debugging打印语句

84
00:03:42,879 --> 00:03:46,000
（学生）我运行了trace

85
00:03:46,000 --> 00:03:49,599
（学生）并设置了掩码的所有位

86
00:03:49,599 --> 00:03:52,879
（学生）大体上跟踪了所有系统调用

87
00:03:52,879 --> 00:03:56,480
（学生）我想我应该是看到了一大堆

88
00:03:56,480 --> 00:03:58,799
（学生）对print语句的追踪

89
00:03:58,799 --> 00:04:00,400
（学生）出现在了内核中

90
00:04:00,400 --> 00:04:03,040
（学生）嗯然后。。。

91
00:04:03,040 --> 00:04:03,760
（学生）我猜想我的打印。。。

92
00:04:03,760 --> 00:04:06,959
（学生）我的打印程序尝试

93
00:04:06,959 --> 00:04:09,840
（学生）输出到控制台

94
00:04:09,840 --> 00:04:12,000
（学生）但是。。。额，输出到控制台，但是

95
00:04:12,000 --> 00:04:15,200
（学生）我很好奇为什么。。。额

96
00:04:15,200 --> 00:04:17,040
（学生）我猜我只是疑惑于

97
00:04:17,040 --> 00:04:20,880
（学生）为什么我们可以在内核里使用printf

98
00:04:22,639 --> 00:04:24,639
嗯好的，我还没有。。。额

99
00:04:24,639 --> 00:04:26,240
我最近还没有看printf代码

100
00:04:26,240 --> 00:04:28,800
但我想应该有一个文件

101
00:04:28,800 --> 00:04:30,720
printf.c，如果你想看的话，你应该可以看到这个文件

102
00:04:30,720 --> 00:04:33,360
以及，如果你想要。。。

103
00:04:34,560 --> 00:04:36,080
理解内核里发生了什么

104
00:04:36,080 --> 00:04:37,280
那我想

105
00:04:37,280 --> 00:04:40,080
printf函数应该被实现在那个文件里

106
00:04:41,120 --> 00:04:43,040
至少我们的版本应该是这样

107
00:04:43,040 --> 00:04:44,560
我不是太清楚，也许。。。

108
00:04:44,560 --> 00:04:45,919
也许有其他老师

109
00:04:45,919 --> 00:04:49,520
可以告诉你具体情况

110
00:04:49,520 --> 00:04:51,120
（老师2）内核中这些print

111
00:04:51,120 --> 00:04:52,639
（老师2）不应该出现在你的追踪(traces)中

112
00:04:52,639 --> 00:04:54,639
（老师2）因为内核中的printf

113
00:04:54,639 --> 00:04:56,000
（老师2）不会调用任何系统调用

114
00:04:56,000 --> 00:04:59,440
（学生）是的，那就是我所想的

115
00:04:59,440 --> 00:05:02,800
（学生）或许。。。或许，输出的追踪信息

116
00:05:02,800 --> 00:05:04,720
（学生）并非来自于那些语句

117
00:05:04,720 --> 00:05:05,919
（老师2）是的，我不认为它们来自

118
00:05:05,919 --> 00:05:08,840
（老师2）内核中的打印语句

119
00:05:08,840 --> 00:05:11,840
（学生）好的

120
00:05:12,479 --> 00:05:16,240
好的，如果

121
00:05:16,240 --> 00:05:18,800
没有其他人想关于syscall实验做发言的话

122
00:05:18,800 --> 00:05:19,680
我想我们可以

123
00:05:19,680 --> 00:05:23,440
开始今天的课程了

124
00:05:23,440 --> 00:05:26,560
我们将会谈一谈

125
00:05:26,560 --> 00:05:31,680
将C转换到汇编的过程

126
00:05:31,680 --> 00:05:33,919
以及处理器（processors），以及。。。

127
00:05:33,919 --> 00:05:35,840
今天的课更像是一堂实践课程

128
00:05:35,840 --> 00:05:38,320
至少，我们的目的在于

129
00:05:38,320 --> 00:05:42,479
让你们熟悉一下risc-v

130
00:05:42,479 --> 00:05:45,039
熟悉一下处理器

131
00:05:45,039 --> 00:05:45,919
熟悉一下汇编语言

132
00:05:45,919 --> 00:05:48,320
以及，熟悉一下

133
00:05:48,320 --> 00:05:49,280
risc-v中的调用约定

134
00:05:49,280 --> 00:05:51,759
这些对于页表是非常重要的

135
00:05:51,759 --> 00:05:53,759
不，不是特别重要

136
00:05:53,759 --> 00:05:56,560
不过，当然了

137
00:05:56,560 --> 00:05:58,160
在这周即将布置的traps实验中

138
00:05:58,160 --> 00:05:59,919
这些将有助于调试

139
00:05:59,919 --> 00:06:01,919
以及实现功能

140
00:06:01,919 --> 00:06:03,120
因为

141
00:06:03,120 --> 00:06:05,360
你们接下来要做的事和陷阱框架（trap frames，译者认为可译作系统调用框架）

142
00:06:05,360 --> 00:06:07,520
以及栈，以及其他种种类似的东西密切相关

143
00:06:07,520 --> 00:06:08,880
所以，那就是

144
00:06:08,880 --> 00:06:10,880
今天的目标

145
00:06:10,880 --> 00:06:13,600
我讲课的第一个目标是。。。嗯，这里可能

146
00:06:13,600 --> 00:06:14,880
有一些内容

147
00:06:14,880 --> 00:06:18,720
是对6.004的复习

148
00:06:18,720 --> 00:06:20,720
也有可能包含

149
00:06:20,720 --> 00:06:22,160
其他的你已经学过的基础课程

150
00:06:22,160 --> 00:06:24,800
我只想简单地回顾一下

151
00:06:24,800 --> 00:06:25,520
比如

152
00:06:25,520 --> 00:06:28,479
看一看如何把C语言转换到

153
00:06:28,479 --> 00:06:29,759
汇编

154
00:06:29,759 --> 00:06:32,840
以及可能有一些关于处理器的知识and maybe a little bit about processor

155
00:06:32,840 --> 00:06:34,720
然后

156
00:06:34,720 --> 00:06:36,240
这里提一句

157
00:06:36,240 --> 00:06:38,400
上课时如果你有感到疑惑的地方

158
00:06:38,400 --> 00:06:41,840
你可以随时打断我

159
00:06:41,840 --> 00:06:43,759
嗯，你们知道的，在C当中

160
00:06:43,759 --> 00:06:45,600
我们有一个main函数

161
00:06:45,600 --> 00:06:47,600
main函数会做一些工作

162
00:06:47,600 --> 00:06:50,479
它可能会打印些什么

163
00:06:50,639 --> 00:06:54,880
然后退出

164
00:06:54,880 --> 00:06:58,000
这看起来很不错

165
00:06:58,000 --> 00:06:59,360
但是，你们都在6.004中学过的

166
00:06:59,360 --> 00:07:02,479
处理器

167
00:07:02,479 --> 00:07:02,720
其实并不能理解C语言

168
00:07:02,720 --> 00:07:05,039
它们只能理解

169
00:07:05,039 --> 00:07:05,919
汇编语言

170
00:07:05,919 --> 00:07:07,759
或者更确切地说

171
00:07:07,759 --> 00:07:09,280
它们只能理解

172
00:07:09,280 --> 00:07:10,160
汇编语言的二进制码

173
00:07:10,160 --> 00:07:13,039
在这张图片上

174
00:07:13,039 --> 00:07:15,280
我在主板中

175
00:07:15,280 --> 00:07:16,639
圈出了risc-v处理器

176
00:07:16,639 --> 00:07:20,080
当我们说某个处理器是risc-v时

177
00:07:20,080 --> 00:07:22,400
这意味着

178
00:07:22,400 --> 00:07:24,319
它可以理解risc-v指令集

179
00:07:24,319 --> 00:07:28,080
所以每一个处理器都有一个关联的isa（指令集架构）

180
00:07:28,080 --> 00:07:32,160
或者关联的指令

181
00:07:32,160 --> 00:07:36,000
该指令集对于该处理器来说

182
00:07:36,000 --> 00:07:37,440
是有效的（可执行的）

183
00:07:37,440 --> 00:07:39,280
每一个指令

184
00:07:39,280 --> 00:07:42,400
都有一个关联的二进制码或操作码

185
00:07:42,400 --> 00:07:45,039
当处理器运行时

186
00:07:45,039 --> 00:07:46,319
遇上特定格式的二进制码

187
00:07:46,319 --> 00:07:50,160
它就会知道执行什么操作

188
00:07:50,160 --> 00:07:52,160
你知道的

189
00:07:52,160 --> 00:07:53,199
这个主板上的处理器

190
00:07:53,199 --> 00:07:56,960
正好能够理解

191
00:07:56,960 --> 00:07:59,120
由C语言编译出的risc-v汇编

192
00:07:59,120 --> 00:08:00,879
所以

193
00:08:00,879 --> 00:08:03,680
让C代码在你的处理器上运行的大致步骤是

194
00:08:03,680 --> 00:08:05,039
写一段C代码

195
00:08:05,039 --> 00:08:07,120
把它编译成汇编

196
00:08:07,120 --> 00:08:08,720
在这步骤之中

197
00:08:08,720 --> 00:08:10,639
会有一些链接（linking）操作以及其他类似操作

198
00:08:10,639 --> 00:08:13,360
但是我们现在上的不是编译原理课（就不多说了）

199
00:08:13,360 --> 00:08:14,960
然后

200
00:08:14,960 --> 00:08:18,479
汇编将被翻译成二进制码

201
00:08:18,479 --> 00:08:19,039
这就是

202
00:08:19,039 --> 00:08:22,639
目标文件

203
00:08:22,639 --> 00:08:26,080
或者说是你看到的.o文件

204
00:08:26,080 --> 00:08:29,280
如果你曾注意到

205
00:08:29,280 --> 00:08:31,759
你的实验文件夹里有什么

206
00:08:31,759 --> 00:08:34,000
在你运行“make qemu”命令后

207
00:08:34,000 --> 00:08:36,240
你将会看到一连串的.o文件

208
00:08:36,240 --> 00:08:37,839
这些就是目标文件

209
00:08:37,839 --> 00:08:40,958
处理器可以理解它们

210
00:08:40,958 --> 00:08:43,279
还有你们已经看到的asm文件

211
00:08:43,279 --> 00:08:45,440
嗯你们好像还没开始写

212
00:08:45,440 --> 00:08:48,480
但是，你们可以回想一下

213
00:08:48,480 --> 00:08:50,680
有一个usas.pl文件被编译成了一个usys.s文件

214
00:08:50,680 --> 00:08:54,320
那个.s文件里面

215
00:08:54,320 --> 00:08:57,519
就是汇编语言

216
00:08:57,519 --> 00:08:59,040
所以你们已经看到过risc-v汇编代码了

217
00:08:59,040 --> 00:09:01,040
如果你上过6.004课程

218
00:09:01,040 --> 00:09:02,880
我相信你们已经看过

219
00:09:02,880 --> 00:09:05,440
大量的汇编代码

220
00:09:05,440 --> 00:09:08,800
总得来说

221
00:09:08,800 --> 00:09:09,680
汇编的结构化程度看起来不如C语言

222
00:09:09,680 --> 00:09:11,920
所以你们只能一行一行的阅读

223
00:09:11,920 --> 00:09:13,040
那些指令

224
00:09:13,040 --> 00:09:14,880
你们会看到一些简单的玩意

225
00:09:14,880 --> 00:09:17,200
比如add

226
00:09:17,200 --> 00:09:20,399
抑或是malt等等

227
00:09:20,399 --> 00:09:22,720
诸如此类的非常多

228
00:09:22,720 --> 00:09:23,920
在汇编中

229
00:09:23,920 --> 00:09:27,440
没有直观的控制流

230
00:09:27,440 --> 00:09:29,279
没有直观的循环语句

231
00:09:29,279 --> 00:09:30,959
没有像C语言中一样直观的函数

232
00:09:30,959 --> 00:09:33,040
你知道的，我们只能看到标签（labels）

233
00:09:33,040 --> 00:09:36,480
而不是真实的函数定义

234
00:09:36,480 --> 00:09:38,560
汇编是相当低级的语言（计算机科学层面）

235
00:09:38,560 --> 00:09:39,760
有大量的其他语言

236
00:09:39,760 --> 00:09:41,440
可以被编译成

237
00:09:41,440 --> 00:09:42,800
汇编语言

238
00:09:42,800 --> 00:09:45,440
嗯，这些步骤

239
00:09:45,440 --> 00:09:46,240
对诸如C++之类的语言

240
00:09:46,240 --> 00:09:49,519
同样适用

241
00:09:49,519 --> 00:09:51,120
你知道的

242
00:09:51,120 --> 00:09:53,440
任何编译型语言

243
00:09:53,440 --> 00:09:56,640
最终在底层都会变成汇编的形式

244
00:09:56,640 --> 00:09:59,920
嗯嗯，这就是

245
00:09:59,920 --> 00:10:01,920
让我们的计算机

246
00:10:01,920 --> 00:10:04,880
能够理解我们写的C代码

247
00:10:04,880 --> 00:10:06,399
的基本步骤

248
00:10:06,399 --> 00:10:08,320
不过，你可能注意到了

249
00:10:08,320 --> 00:10:10,399
在课程中

250
00:10:10,399 --> 00:10:13,680
我们一直都有提到risc-v汇编

251
00:10:13,680 --> 00:10:15,200
以及risc-v处理器

252
00:10:15,200 --> 00:10:17,360
那是因为

253
00:10:17,360 --> 00:10:19,360
额，这件事非常重要

254
00:10:19,360 --> 00:10:20,880
因为汇编语言的种类有很多

255
00:10:20,880 --> 00:10:23,360
所以对于你们个人来说

256
00:10:23,360 --> 00:10:24,640
你们是不太可能用到risc-v的

257
00:10:24,640 --> 00:10:26,560
你们不太可能会在risc-v处理器上

258
00:10:26,560 --> 00:10:27,920
运行linux

259
00:10:27,920 --> 00:10:30,959
事实上绝大多数现代计算机

260
00:10:30,959 --> 00:10:31,360
都运行在

261
00:10:31,360 --> 00:10:34,480
x86处理器上

262
00:10:34,480 --> 00:10:37,760
有时候你们会看到x86-64

263
00:10:37,760 --> 00:10:40,959
这是一个不同（于risc-v）的指令集架构

264
00:10:40,959 --> 00:10:42,399
这是一个不同的指令集

265
00:10:42,399 --> 00:10:44,240
它看起来和risc-v十分相似

266
00:10:44,240 --> 00:10:46,720
但这才是你们自己的个人电脑上

267
00:10:46,720 --> 00:10:50,160
常常见到的指令集

268
00:10:51,760 --> 00:10:55,120
如果你们用intel的话

269
00:10:55,120 --> 00:10:58,399
intel的cpu实现了x86指令集

270
00:10:58,399 --> 00:11:02,240
amd的cpu也实现了（x86指令集）

271
00:11:02,240 --> 00:11:06,560
这两者（指x86与risc-v）之间

272
00:11:06,560 --> 00:11:08,160
有着相当重要的区别

273
00:11:08,160 --> 00:11:09,600
乍一看很相似

274
00:11:09,600 --> 00:11:12,880
实际上它们并没有那么相似

275
00:11:12,880 --> 00:11:15,839
归根结底

276
00:11:15,839 --> 00:11:18,640
risc-v被我们称作risc

277
00:11:18,640 --> 00:11:20,079
risc意为

278
00:11:20,079 --> 00:11:23,839
精简指令集

279
00:11:23,839 --> 00:11:28,079
x86-64则被称为cisc

280
00:11:28,079 --> 00:11:32,720
或者说是复杂指令集

281
00:11:34,800 --> 00:11:37,920
在它们之间

282
00:11:37,920 --> 00:11:38,640
有一系列的不同点

283
00:11:38,640 --> 00:11:40,320
其中一点就是

284
00:11:40,320 --> 00:11:42,000
x86-64中指令的数量（与risc-v对比）

285
00:11:42,000 --> 00:11:45,120
事实上

286
00:11:45,120 --> 00:11:48,240
这一点可以大书特书

287
00:11:48,240 --> 00:11:51,279
而在intel的手册中

288
00:11:51,279 --> 00:11:55,120
我们可以找到

289
00:11:55,120 --> 00:11:58,000
risc要实现多少条指令

290
00:11:58,000 --> 00:11:59,120
（x86-64的）参考手册（这句发言逻辑略混乱）

291
00:11:59,120 --> 00:12:02,160
是三本厚书

292
00:12:02,160 --> 00:12:05,600
那里面包含了整个（x86-64）指令集

293
00:12:05,600 --> 00:12:08,720
有统计资料表明

294
00:12:08,720 --> 00:12:11,760
自x86-64于70年代发布以来

295
00:12:11,760 --> 00:12:16,639
intel一直以

296
00:12:16,639 --> 00:12:21,360
每月3条指令的速度

297
00:12:21,360 --> 00:12:24,320
向x86-64指令集中添加指令

298
00:12:24,320 --> 00:12:24,800
我估计

299
00:12:24,800 --> 00:12:28,320
x86-64指令集大概有

300
00:12:28,320 --> 00:12:31,040
15000条指令

301
00:12:31,360 --> 00:12:35,760
而另一方面

302
00:12:35,760 --> 00:12:37,440
就risc-v来讲

303
00:12:37,440 --> 00:12:39,440
仅仅两份文档

304
00:12:39,440 --> 00:12:42,880
就涵盖了risc-v指令的所有内容

305
00:12:42,880 --> 00:12:44,959
我们并不打算

306
00:12:44,959 --> 00:12:45,920
让你们

307
00:12:45,920 --> 00:12:48,639
死记硬背课程中的

308
00:12:48,639 --> 00:12:50,399
每一条risc-v指令

309
00:12:50,399 --> 00:12:52,720
但如果你对这些指令感兴趣的话

310
00:12:52,720 --> 00:12:54,160
或者对某个指令感到迷惑

311
00:12:54,160 --> 00:12:55,920
。。。

312
00:12:55,920 --> 00:12:58,959
你可以到课程网站上

313
00:12:58,959 --> 00:13:00,000
。。。

314
00:13:00,000 --> 00:13:03,519
在references标签下可以看到

315
00:13:03,519 --> 00:13:05,680
在risc-v段落下我们放了一个链接

316
00:13:05,680 --> 00:13:07,440
有已获得授权的指令

317
00:13:07,440 --> 00:13:10,639
也有未获得授权的指令

318
00:13:10,639 --> 00:13:12,880
这个文档

319
00:13:12,880 --> 00:13:15,200
可以给你提供一系列关于指令集架构的

320
00:13:15,200 --> 00:13:16,800
信息

321
00:13:16,800 --> 00:13:19,200
不过请注意这个是240页

322
00:13:19,200 --> 00:13:20,480
。。。

323
00:13:20,480 --> 00:13:23,040
这个是135页

324
00:13:23,040 --> 00:13:25,360
比起x86-64指令集（的手册）

325
00:13:25,360 --> 00:13:28,800
这两份文档明显小很多

326
00:13:28,800 --> 00:13:31,839
risc-v的这个特点

327
00:13:31,839 --> 00:13:36,000
对我们来说非常棒

328
00:13:36,000 --> 00:13:38,800
在risc-v中，有（比x86）更少的指令

329
00:13:38,800 --> 00:13:39,920
。。。

330
00:13:39,920 --> 00:13:43,040
这些指令也更简单

331
00:13:43,040 --> 00:13:44,320
。。。

332
00:13:44,320 --> 00:13:48,800
我之所以这么说是因为

333
00:13:48,800 --> 00:13:52,399
x86-64中的指令实在太多了

334
00:13:52,399 --> 00:13:53,519
我提到的指令就是

335
00:13:53,519 --> 00:13:55,760
像malt或者sub那样的东西

336
00:13:55,760 --> 00:13:58,720
x86-64中大量的指令集完成不止一件任务

337
00:13:58,720 --> 00:14:00,079
。。。

338
00:14:00,079 --> 00:14:02,560
它们执行了一系列

339
00:14:02,560 --> 00:14:03,920

。。。
340
00:14:03,920 --> 00:14:06,639
复杂的操作

341
00:14:06,639 --> 00:14:07,360
并给出结果

342
00:14:07,360 --> 00:14:09,519
而在risc-v中就不是这样

343
00:14:09,519 --> 00:14:12,000
risc-v往往

344
00:14:12,000 --> 00:14:12,399
。。。

345
00:14:12,399 --> 00:14:14,240
执行更少的操作

346
00:14:14,240 --> 00:14:16,000
所以它每次的运行周期更短

347
00:14:16,000 --> 00:14:19,279
x86-64和risc-v的差别

348
00:14:19,279 --> 00:14:21,040
只是设计师所做出的一种权衡

349
00:14:21,040 --> 00:14:21,920
。。。

350
00:14:21,920 --> 00:14:25,360
事实上并没有。。。

351
00:14:25,360 --> 00:14:28,399
嗯你知道的。。。

352
00:14:28,399 --> 00:14:30,480
并没有真正意义上的

353
00:14:30,480 --> 00:14:31,519
精简指令集

354
00:14:31,519 --> 00:14:34,320
比复杂指令集更好的说法

355
00:14:34,320 --> 00:14:35,199
。。。

356
00:14:35,199 --> 00:14:37,279
两种指令集都有它们各自的用途

357
00:14:37,279 --> 00:14:38,320
。。。

358
00:14:38,320 --> 00:14:40,480
以此类推

359
00:14:40,480 --> 00:14:42,399
risc-v还有一个很酷的优点

360
00:14:42,399 --> 00:14:43,519
与x86不同的是

361
00:14:43,519 --> 00:14:47,760
risc-v是开源的

362
00:14:47,760 --> 00:14:51,760
它是市面上仅有的开源指令集之一

363
00:14:51,760 --> 00:14:53,839
所以这意味着

364
00:14:53,839 --> 00:14:55,760
任何人都能用risc-v开发处理器

365
00:14:55,760 --> 00:14:57,279
。。。

366
00:14:57,279 --> 00:14:59,040
risc诞生于

367
00:14:59,040 --> 00:15:00,560
。。。

368
00:15:00,560 --> 00:15:02,720
uc berkeley的一个项目

369
00:15:02,720 --> 00:15:04,000
所以uc berkeley是其发源地

370
00:15:04,000 --> 00:15:05,440
从那时起

371
00:15:05,440 --> 00:15:07,839
就有许多公司使用并赞助risc-v

372
00:15:07,839 --> 00:15:09,760
你可以在网上找到名单

373
00:15:09,760 --> 00:15:11,120
但是你知道的

374
00:15:11,120 --> 00:15:13,279
有大量的公司

375
00:15:13,279 --> 00:15:16,079
致力于赞助开源指令集

376
00:15:16,079 --> 00:15:17,760
我记得最近

377
00:15:17,760 --> 00:15:18,720
（某公司）

378
00:15:18,720 --> 00:15:22,320
（大概是risc-v处理器的主板制造商）

379
00:15:22,320 --> 00:15:25,279
发布了一则公告

380
00:15:25,279 --> 00:15:26,079
宣称

381
00:15:26,079 --> 00:15:29,680
他们将发布

382
00:15:29,680 --> 00:15:31,279
用于个人PC的主板

383
00:15:31,279 --> 00:15:32,639
你们懂得

384
00:15:32,639 --> 00:15:34,560
那是一个为个人PC设计的

385
00:15:34,560 --> 00:15:35,839
risc-v处理器

386
00:15:35,839 --> 00:15:37,759
我记得

387
00:15:37,759 --> 00:15:39,199
这个消息是上周发布的

388
00:15:39,199 --> 00:15:41,600
也可能是两周前

389
00:15:41,600 --> 00:15:43,040
如果你对这玩意感到好奇

390
00:15:43,040 --> 00:15:44,720
嗯应该会很好奇

391
00:15:44,720 --> 00:15:46,880
上完6.s081之后我就很想用一用risc-v

392
00:15:46,880 --> 00:15:48,320
。。。

393
00:15:48,320 --> 00:15:50,160
到时候

394
00:15:50,160 --> 00:15:51,759
就有一个能让我们在自己的电脑上

395
00:15:51,759 --> 00:15:55,120
运行linux的（risc-v）处理器了

396
00:15:55,120 --> 00:15:56,880
在你们的日常生活中

397
00:15:56,880 --> 00:15:59,360
最可能使用到的就是精简指令集

398
00:15:59,360 --> 00:16:02,079
也许你们并没有注意到

399
00:16:02,079 --> 00:16:05,519
比如arm汇编

400
00:16:05,519 --> 00:16:09,360
arm也是一个精简指令集

401
00:16:09,360 --> 00:16:11,199
。。。

402
00:16:11,199 --> 00:16:14,480
高通的骁龙系列处理器

403
00:16:14,480 --> 00:16:17,759
就是arm架构的

404
00:16:17,759 --> 00:16:19,040
处理器

405
00:16:19,040 --> 00:16:22,800
所以如果你有一个安卓手机

406
00:16:22,800 --> 00:16:26,800
你很有可能

407
00:16:26,800 --> 00:16:30,160
在使用精简指令集

408
00:16:30,160 --> 00:16:34,079
即使你用的是iOS

409
00:16:34,079 --> 00:16:35,680
iOS。。。我忘了那个（处理器的）名字。。。

410
00:16:35,680 --> 00:16:36,000
苹果公司

411
00:16:36,000 --> 00:16:39,199
也在它们的处理器中

412
00:16:39,199 --> 00:16:41,440
使用了某些版本的

413
00:16:41,440 --> 00:16:42,800
arm架构

414
00:16:42,800 --> 00:16:46,480
iPad，iPhone

415
00:16:46,480 --> 00:16:48,800
以及大多数苹果设备都运行在那个处理器上

416
00:16:48,800 --> 00:16:50,000
精简指令集

417
00:16:50,000 --> 00:16:51,519
可谓到处都是

418
00:16:51,519 --> 00:16:54,800
如果你想在现实中

419
00:16:54,800 --> 00:16:58,079
而非qemu中找到risc-v去使用

420
00:16:58,079 --> 00:17:01,680
你可以在诸如一体机（intergrated devices）上

421
00:17:01,680 --> 00:17:05,280
找到它

422
00:17:05,280 --> 00:17:07,039
它并不像x86-64那样

423
00:17:07,039 --> 00:17:10,240
随处可见

424
00:17:10,240 --> 00:17:13,359
但是。。嗯。。。

425
00:17:13,359 --> 00:17:15,679
我想，正如刚刚lucas在聊天中说的

426
00:17:15,679 --> 00:17:18,240
我想苹果正在将macs（指mac系列PC？）

427
00:17:18,240 --> 00:17:20,559
迁移到arm架构

428
00:17:20,559 --> 00:17:21,839
我记得应该就是这两年的事情

429
00:17:21,839 --> 00:17:23,199
可以肯定地说

430
00:17:23,199 --> 00:17:25,919
他们正朝着精简指令集发展

431
00:17:25,919 --> 00:17:28,720
考虑到intel指令集架构

432
00:17:28,720 --> 00:17:29,440
如此庞大

433
00:17:29,440 --> 00:17:31,520
以及考虑到其根源

434
00:17:31,520 --> 00:17:33,200
全在于

435
00:17:33,200 --> 00:17:34,320
他们非常关心

436
00:17:34,320 --> 00:17:36,799
向后兼容性

437
00:17:36,799 --> 00:17:39,120
因此即使是三四十年前的

438
00:17:39,120 --> 00:17:40,000
intel代码

439
00:17:40,000 --> 00:17:42,880
也可以

440
00:17:42,880 --> 00:17:43,440
。。。

441
00:17:43,440 --> 00:17:46,320
在现代intel处理器上运行

442
00:17:46,320 --> 00:17:48,160
intel并没有删除任何指令

443
00:17:48,160 --> 00:17:49,360
所以他们（的cpu）可以保持

444
00:17:49,360 --> 00:17:50,320
向后兼容性

445
00:17:50,320 --> 00:17:52,559
而risc-v则更为现代化

446
00:17:52,559 --> 00:17:55,200
所以不用担心（risc-v会存在这些历史遗留问题）

447
00:17:55,200 --> 00:17:58,160
让我们回到这些手册

448
00:17:58,160 --> 00:18:01,120
risc-v（手册）很独特地分开了

449
00:18:01,120 --> 00:18:02,400
这是risc-v中的

450
00:18:02,400 --> 00:18:04,559
基整数指令集(base integer instruction)

451
00:18:04,559 --> 00:18:06,080
额（开始混乱）

452
00:18:06,080 --> 00:18:09,039
（混乱地吐槽intel中？）

453
00:18:09,039 --> 00:18:10,880
如果处理器有15000条指令

454
00:18:10,880 --> 00:18:12,559
我们几乎不可能有效地

455
00:18:12,559 --> 00:18:13,679
在流水线上传送指令（pipeline them）

456
00:18:13,679 --> 00:18:15,600
我们为啥需要这么多

457
00:18:15,600 --> 00:18:17,120
我的意思是

458
00:18:17,120 --> 00:18:19,039
这么多指令只是为了向后兼容性

459
00:18:19,039 --> 00:18:20,880
是否使用完全取决于你自己

460
00:18:20,880 --> 00:18:22,400
是否觉得（向后兼容性）重要

461
00:18:22,400 --> 00:18:24,400
不过我估计这些指令中

462
00:18:24,400 --> 00:18:25,840
绝大多数

463
00:18:25,840 --> 00:18:28,000
都是cmd使用的

464
00:18:28,000 --> 00:18:28,880
专属的

465
00:18:28,880 --> 00:18:32,320
一类特殊指令

466
00:18:32,320 --> 00:18:34,880
你不可能（会用上这些指令）

467
00:18:34,880 --> 00:18:36,720
我从来没见过谁

468
00:18:36,720 --> 00:18:38,480
能完全利用15000条intel指令

469
00:18:38,480 --> 00:18:40,640
这些指令中绝大多数的诞生

470
00:18:40,640 --> 00:18:42,320
都是为了满足向后兼容性的需求

471
00:18:42,320 --> 00:18:44,000
以及cmd的需求

472
00:18:44,000 --> 00:18:46,080
正如我之前说的（回到正题 ）

473
00:18:46,080 --> 00:18:47,039
这个

474
00:18:47,039 --> 00:18:50,160
基整数指令集

475
00:18:50,160 --> 00:18:52,640
包含了所有正常的像add

476
00:18:52,640 --> 00:18:53,679
multiply

477
00:18:53,679 --> 00:18:56,720
之类的指令

478
00:18:56,720 --> 00:18:58,559
然后处理器可以选择性地实现一些其他模块

479
00:18:58,559 --> 00:19:00,400
你可以在这边看到（这些模块）

480
00:19:00,400 --> 00:19:02,480
可能在你的屏幕上显示的并不清晰

481
00:19:02,480 --> 00:19:03,919
比如

482
00:19:03,919 --> 00:19:06,160
如果你想要一个

483
00:19:06,160 --> 00:19:07,840
支持单精度浮点数的标准扩展的

484
00:19:07,840 --> 00:19:09,440
处理器

485
00:19:09,440 --> 00:19:12,160
你可以导入f模块

486
00:19:12,160 --> 00:19:13,919
risc-v更容易

487
00:19:13,919 --> 00:19:14,640
支持

488
00:19:14,640 --> 00:19:18,080
向后兼容性

489
00:19:18,080 --> 00:19:19,760
因为你知道你导入并支持了

490
00:19:19,760 --> 00:19:22,240
哪些模块

491
00:19:22,240 --> 00:19:25,360
然后编译器可以做出选择

492
00:19:25,360 --> 00:19:27,280
编译器会说：好的

493
00:19:27,280 --> 00:19:28,960
这个处理器告诉我

494
00:19:28,960 --> 00:19:30,799
它支持这些模块

495
00:19:30,799 --> 00:19:33,679
所以我只可以用这些模块来编译这些代码

496
00:19:33,679 --> 00:19:36,400
好的，（某学生）说看起来

497
00:19:36,400 --> 00:19:38,400
用x86处理器

498
00:19:38,400 --> 00:19:39,440
代替risc-v处理器的唯一优势

499
00:19:39,440 --> 00:19:40,640
就是你可以获得性能提升

500
00:19:40,640 --> 00:19:42,559
然而这些性能提升

501
00:19:42,559 --> 00:19:44,000
带来了大量的代价与复杂性

502
00:19:44,000 --> 00:19:45,280
以及潜在安全问题

503
00:19:45,280 --> 00:19:46,880
我的问题是为什么我们仍然在用x86

504
00:19:46,880 --> 00:19:48,799
而非迁移到其他处理器架构

505
00:19:48,799 --> 00:19:50,000
比如risc-v

506
00:19:50,000 --> 00:19:52,720
嗯好的，主要原因是

507
00:19:52,720 --> 00:19:54,720
整个世界一直在使用x86

508
00:19:54,720 --> 00:19:57,679
（大概有多少年）我太记得清了

509
00:19:57,679 --> 00:19:58,400
。。。

510
00:19:58,400 --> 00:20:02,000
risc-v也是非常现代化的

511
00:20:02,000 --> 00:20:04,320
整个世界一直都在用x86

512
00:20:04,320 --> 00:20:06,159
如果突然地

513
00:20:06,159 --> 00:20:09,919
开始把处理器都换成risc-v

514
00:20:09,919 --> 00:20:14,000
这会带来很大的风险

515
00:20:14,000 --> 00:20:16,240
这会使得很多重要的东西

516
00:20:16,240 --> 00:20:17,440
失去支持

517
00:20:17,440 --> 00:20:19,760
also there are like intel does do

518
00:20:19,760 --> 00:20:21,520
interesting things within their

519
00:20:21,520 --> 00:20:22,799
processors

520
00:20:22,799 --> 00:20:25,200
it's like security wise there are

521
00:20:25,200 --> 00:20:27,360
enclaves and intel processors and

522
00:20:27,360 --> 00:20:28,799
there's things that um

523
00:20:28,799 --> 00:20:30,559
they've been doing in recent years to

524
00:20:30,559 --> 00:20:32,720
try to try and give you extra

525
00:20:32,720 --> 00:20:35,440
added security and uh some of those

526
00:20:35,440 --> 00:20:37,120
instructions that intel does implement

527
00:20:37,120 --> 00:20:38,799
which are hyper-specific

528
00:20:38,799 --> 00:20:41,840
can be really efficient for certain

529
00:20:41,840 --> 00:20:44,480
computations uh and so they have so many

530
00:20:44,480 --> 00:20:46,720
instructions that there's often you know

531
00:20:46,720 --> 00:20:48,799
a perfect instruction for a situation

532
00:20:48,799 --> 00:20:50,880
that may be more efficient than

533
00:20:50,880 --> 00:20:54,080
than what exists within risk five but a

534
00:20:54,080 --> 00:20:55,679
more practical answer is that risk five

535
00:20:55,679 --> 00:20:57,360
is relatively new and we just don't

536
00:20:57,360 --> 00:20:58,640
you know nobody's really making

537
00:20:58,640 --> 00:21:00,320
processors for personal computers i

538
00:21:00,320 --> 00:21:01,120
think the

539
00:21:01,120 --> 00:21:04,080
sci 5 announcement is super recent um

540
00:21:04,080 --> 00:21:04,640
and

541
00:21:04,640 --> 00:21:06,080
they're kind of the first people to be

542
00:21:06,080 --> 00:21:08,880
doing that so on a practical level

543
00:21:08,880 --> 00:21:10,960
that and the inability to run all the

544
00:21:10,960 --> 00:21:12,880
software design for intel

545
00:21:12,880 --> 00:21:17,280
is is my best answer

546
00:21:17,280 --> 00:21:19,679
so we've been now chatting a little bit

547
00:21:19,679 --> 00:21:22,880
about assembly so i just wanted to

548
00:21:22,880 --> 00:21:26,640
take a look at some actual assembly code

549
00:21:26,640 --> 00:21:30,000
so here is uh the

550
00:21:30,000 --> 00:21:32,000
c code for what's below so this is a

551
00:21:32,000 --> 00:21:34,320
simple function that has an accumulator

552
00:21:34,320 --> 00:21:37,679
we loop from zero to n and we

553
00:21:37,679 --> 00:21:40,640
sum up all the numbers from uh from zero

554
00:21:40,640 --> 00:21:41,919
to n

555
00:21:41,919 --> 00:21:44,960
and then return that value and uh

556
00:21:44,960 --> 00:21:46,480
at its simplest level you know this is

557
00:21:46,480 --> 00:21:48,400
the easiest kind of assembly that you

558
00:21:48,400 --> 00:21:50,799
can get out of compiling that program

559
00:21:50,799 --> 00:21:53,840
if you actually go into your own

560
00:21:53,840 --> 00:21:55,360
computer and you write the c

561
00:21:55,360 --> 00:21:57,200
code and you try to compile it you will

562
00:21:57,200 --> 00:21:58,480
end up with something

563
00:21:58,480 --> 00:22:01,440
that likely looks quite different and

564
00:22:01,440 --> 00:22:03,360
that's true for a variety of reasons we

565
00:22:03,360 --> 00:22:03,919
haven't

566
00:22:03,919 --> 00:22:05,280
some of which we'll get to and some of

567
00:22:05,280 --> 00:22:07,120
which are compiler specific

568
00:22:07,120 --> 00:22:10,480
so modern compilers make a large number

569
00:22:10,480 --> 00:22:12,159
of optimizations

570
00:22:12,159 --> 00:22:15,440
um within when they compile your c2

571
00:22:15,440 --> 00:22:16,799
assembly and so your assembly

572
00:22:16,799 --> 00:22:18,400
instructions may look different

573
00:22:18,400 --> 00:22:20,640
for instance while you're debugging in

574
00:22:20,640 --> 00:22:22,400
gdv you may come across something that

575
00:22:22,400 --> 00:22:23,360
tells you that it's

576
00:22:23,360 --> 00:22:26,159
some variable has been optimized out and

577
00:22:26,159 --> 00:22:27,919
that means that the compiler decided it

578
00:22:27,919 --> 00:22:29,440
didn't need that variable

579
00:22:29,440 --> 00:22:32,400
uh and so that'll be gone effectively

580
00:22:32,400 --> 00:22:33,600
from the program

581
00:22:33,600 --> 00:22:35,200
but yeah and it's at its most

582
00:22:35,200 --> 00:22:36,960
straightforward

583
00:22:36,960 --> 00:22:39,840
we're moving uh the value that's in a

584
00:22:39,840 --> 00:22:40,480
zero to t

585
00:22:40,480 --> 00:22:43,039
zero we're setting a zero to zero and

586
00:22:43,039 --> 00:22:43,840
then

587
00:22:43,840 --> 00:22:47,280
we are just adding what's in t zero to a

588
00:22:47,280 --> 00:22:47,760
zero

589
00:22:47,760 --> 00:22:50,080
for every iteration of a loop until t

590
00:22:50,080 --> 00:22:52,400
zero reaches zero

591
00:22:52,400 --> 00:22:53,679
and that's all that's going on in this

592
00:22:53,679 --> 00:22:57,280
piece uh amir your hands erased

593
00:22:57,360 --> 00:22:59,919
yeah i was wondering what dot section

594
00:22:59,919 --> 00:23:00,720
dot text

595
00:23:00,720 --> 00:23:03,679
and dot global do global means that you

596
00:23:03,679 --> 00:23:04,240
can

597
00:23:04,240 --> 00:23:06,880
include this from other files so if we

598
00:23:06,880 --> 00:23:08,960
actually hop into

599
00:23:08,960 --> 00:23:14,240
uh let's see def.h

600
00:23:14,240 --> 00:23:17,360
this is the file that you're uh will if

601
00:23:17,360 --> 00:23:18,880
you aren't already you will become quite

602
00:23:18,880 --> 00:23:20,159
familiar with this

603
00:23:20,159 --> 00:23:22,320
includes basically all of the functions

604
00:23:22,320 --> 00:23:23,679
within the kernel that you may want to

605
00:23:23,679 --> 00:23:24,880
be using

606
00:23:24,880 --> 00:23:28,159
and uh within here you know we can see

607
00:23:28,159 --> 00:23:29,600
that in my

608
00:23:29,600 --> 00:23:32,159
my file i've included the definitions to

609
00:23:32,159 --> 00:23:33,360
these functions

610
00:23:33,360 --> 00:23:37,600
and so that dot global make sure that

611
00:23:37,600 --> 00:23:39,679
that these these functions can be called

612
00:23:39,679 --> 00:23:41,120
from other places

613
00:23:41,120 --> 00:23:44,159
and dot text just says this is code

614
00:23:44,159 --> 00:23:47,760
so if you recall from figure 3.4

615
00:23:47,760 --> 00:23:51,679
in the book so that's if we go

616
00:23:51,679 --> 00:23:55,919
to the book

617
00:23:56,320 --> 00:23:59,600
and we go into page tables

618
00:23:59,600 --> 00:24:02,640
process address space so in here in this

619
00:24:02,640 --> 00:24:03,760
diagram

620
00:24:03,760 --> 00:24:05,760
that's the same thing this is text so it

621
00:24:05,760 --> 00:24:08,480
just means code

622
00:24:09,279 --> 00:24:13,360
that answer your question okay thanks

623
00:24:14,799 --> 00:24:18,159
and so if we want to run let's say we

624
00:24:18,159 --> 00:24:19,600
have some assembly

625
00:24:19,600 --> 00:24:21,840
also if you ever find yourself

626
00:24:21,840 --> 00:24:23,200
interested in

627
00:24:23,200 --> 00:24:26,240
what the kernel looks like we can go

628
00:24:26,240 --> 00:24:28,960
inside the after you compile you can

629
00:24:28,960 --> 00:24:30,840
look in the file kernel

630
00:24:30,840 --> 00:24:35,520
kernel.asm and this is the full kind of

631
00:24:35,520 --> 00:24:39,360
assembly for the kernel

632
00:24:39,360 --> 00:24:41,919
of xv6 and each of these numbers on the

633
00:24:41,919 --> 00:24:43,120
left here

634
00:24:43,120 --> 00:24:45,520
is a label that tells you where in

635
00:24:45,520 --> 00:24:46,320
memory this

636
00:24:46,320 --> 00:24:48,960
in this instruction will be and that'll

637
00:24:48,960 --> 00:24:50,640
come in quite handy

638
00:24:50,640 --> 00:24:54,720
and so here is the here's the actual uh

639
00:24:54,720 --> 00:24:56,240
here's the actual assembly code and you

640
00:24:56,240 --> 00:24:59,039
can see the labels for the functions

641
00:24:59,039 --> 00:25:00,320
and where they're declared so this is

642
00:25:00,320 --> 00:25:03,279
this is a can be really really useful as

643
00:25:03,279 --> 00:25:04,320
we're debugging code

644
00:25:04,320 --> 00:25:06,080
and hopefully i'll be able to show that

645
00:25:06,080 --> 00:25:07,600
in a second

646
00:25:07,600 --> 00:25:10,720
but for now we'll jump back to this

647
00:25:10,720 --> 00:25:11,520
first function

648
00:25:11,520 --> 00:25:14,320
sum2 and we'll just see how we can

649
00:25:14,320 --> 00:25:15,440
examine that

650
00:25:15,440 --> 00:25:19,600
inside of gdd so the first step is i

651
00:25:19,600 --> 00:25:21,760
have my two windows here

652
00:25:21,760 --> 00:25:23,840
what's the difference between asm and s

653
00:25:23,840 --> 00:25:25,200
files

654
00:25:25,200 --> 00:25:28,720
um i'm not 100

655
00:25:28,720 --> 00:25:31,039
certain they're both assembly i think

656
00:25:31,039 --> 00:25:33,440
the dot asm file includes a bunch of

657
00:25:33,440 --> 00:25:35,360
extra annotations that aren't included

658
00:25:35,360 --> 00:25:35,760
in dot

659
00:25:35,760 --> 00:25:38,080
s so usually when you compile your c

660
00:25:38,080 --> 00:25:40,000
code to

661
00:25:40,000 --> 00:25:42,000
dot s you'll end up with something that

662
00:25:42,000 --> 00:25:43,360
doesn't include all of those line

663
00:25:43,360 --> 00:25:45,600
numbers and things like that so

664
00:25:45,600 --> 00:25:46,799
if you're curious about how we get the

665
00:25:46,799 --> 00:25:49,039
dot asm file i think the makefile

666
00:25:49,039 --> 00:25:52,080
um will tell you the exact steps used to

667
00:25:52,080 --> 00:25:56,880
get that and so

668
00:25:56,880 --> 00:25:58,480
if we're we're in our terminal we have

669
00:25:58,480 --> 00:26:00,559
our two uh two windows

670
00:26:00,559 --> 00:26:03,919
so the first thing to do is of course uh

671
00:26:03,919 --> 00:26:08,480
get qmu up and running so we can

672
00:26:08,480 --> 00:26:10,640
start it within gdb mode so now we're

673
00:26:10,640 --> 00:26:11,919
we're frozen here

674
00:26:11,919 --> 00:26:15,919
and then we can start gdb uh

675
00:26:15,919 --> 00:26:18,480
and what uh what what what uh professor

676
00:26:18,480 --> 00:26:20,559
crasher showed last week

677
00:26:20,559 --> 00:26:22,400
and which i think some people were

678
00:26:22,400 --> 00:26:24,000
excited about if you type tui

679
00:26:24,000 --> 00:26:26,559
enable you get this nice window which is

680
00:26:26,559 --> 00:26:28,400
empty for now but will come in

681
00:26:28,400 --> 00:26:30,799
quite useful as you're debugging so we

682
00:26:30,799 --> 00:26:32,960
can set a breakpoint and i should note

683
00:26:32,960 --> 00:26:35,360
that all this code is living inside the

684
00:26:35,360 --> 00:26:37,360
kernel none of this is in user space

685
00:26:37,360 --> 00:26:38,720
so we don't have any of those annoying

686
00:26:38,720 --> 00:26:40,720
problems setting breakpoints so i can

687
00:26:40,720 --> 00:26:42,080
set a breakpoint

688
00:26:42,080 --> 00:26:44,799
in the function sum2 and then just

689
00:26:44,799 --> 00:26:47,200
continue running

690
00:26:47,200 --> 00:26:50,640
and run that function and now

691
00:26:50,640 --> 00:26:53,679
so the first window that you see in tui

692
00:26:53,679 --> 00:26:57,279
is the source window

693
00:26:57,279 --> 00:26:59,840
uh yes as david is saying those those

694
00:26:59,840 --> 00:27:01,919
numbers on the left of kernel.asm

695
00:27:01,919 --> 00:27:05,279
are really useful when you're debugging

696
00:27:05,279 --> 00:27:07,440
things and you get an address

697
00:27:07,440 --> 00:27:09,679
it'll tell you so you can see now even

698
00:27:09,679 --> 00:27:11,760
here we can see that the program so pc

699
00:27:11,760 --> 00:27:13,360
here in gdb

700
00:27:13,360 --> 00:27:15,200
is the program counter so we can see

701
00:27:15,200 --> 00:27:16,880
this address 8 0 0

702
00:27:16,880 --> 00:27:20,360
so on and so forth if we go into

703
00:27:20,360 --> 00:27:21,840
kernel.asm

704
00:27:21,840 --> 00:27:24,320
and we search for that specific address

705
00:27:24,320 --> 00:27:26,880
we can see that it's the

706
00:27:26,880 --> 00:27:28,799
uh well it comes up twice because it's a

707
00:27:28,799 --> 00:27:30,880
function call but if we look here this

708
00:27:30,880 --> 00:27:32,080
is that address

709
00:27:32,080 --> 00:27:35,120
it's the top of the sum2 function so

710
00:27:35,120 --> 00:27:37,600
if you see any time you see one of these

711
00:27:37,600 --> 00:27:38,399
um

712
00:27:38,399 --> 00:27:39,760
all the kernel addresses will look

713
00:27:39,760 --> 00:27:44,159
something like 0x8000

714
00:27:44,159 --> 00:27:48,080
some numbers those uh those addresses

715
00:27:48,080 --> 00:27:50,240
you can jump straight into kernel.asm

716
00:27:50,240 --> 00:27:51,760
and find the exact

717
00:27:51,760 --> 00:27:53,679
line of assembly where the problem is

718
00:27:53,679 --> 00:27:54,880
occurring and then you can set your

719
00:27:54,880 --> 00:27:56,480
breakpoints accordingly

720
00:27:56,480 --> 00:27:59,840
but for now uh that top window in tui

721
00:27:59,840 --> 00:28:03,039
is source and if we want to look at

722
00:28:03,039 --> 00:28:04,640
specifically the assembly we can do

723
00:28:04,640 --> 00:28:08,000
layout ngdasm

724
00:28:08,000 --> 00:28:10,000
and that'll give us all of the assembly

725
00:28:10,000 --> 00:28:11,120
instructions

726
00:28:11,120 --> 00:28:13,760
and we can also look at the registers if

727
00:28:13,760 --> 00:28:16,159
we type layout reg we'll get assembly

728
00:28:16,159 --> 00:28:18,559
and registers and if you find yourself

729
00:28:18,559 --> 00:28:19,919
you know wanting to scroll through

730
00:28:19,919 --> 00:28:21,360
things

731
00:28:21,360 --> 00:28:22,799
now that we have three windows we need

732
00:28:22,799 --> 00:28:24,559
to specify which one is focused so if i

733
00:28:24,559 --> 00:28:25,919
want to look through all the registers

734
00:28:25,919 --> 00:28:26,720
i'm going to focus

735
00:28:26,720 --> 00:28:29,760
reg and now my focus is on the register

736
00:28:29,760 --> 00:28:31,520
window so if i

737
00:28:31,520 --> 00:28:33,600
move the arrow keys or scroll it'll

738
00:28:33,600 --> 00:28:35,360
start scrolling that window

739
00:28:35,360 --> 00:28:38,080
so for now we can focus on the assembly

740
00:28:38,080 --> 00:28:39,520
window

741
00:28:39,520 --> 00:28:41,039
and once we're here we can see all of

742
00:28:41,039 --> 00:28:42,559
the things uh

743
00:28:42,559 --> 00:28:44,960
so let's see we can see in the registry

744
00:28:44,960 --> 00:28:46,640
register window we can see that t

745
00:28:46,640 --> 00:28:49,760
0 contains this value we can see that a0

746
00:28:49,760 --> 00:28:51,840
contains this value

747
00:28:51,840 --> 00:28:54,159
and as we step through the assembly we

748
00:28:54,159 --> 00:28:55,200
can watch

749
00:28:55,200 --> 00:28:59,279
see okay t 0 just got the value of a0

750
00:28:59,279 --> 00:28:59,760
which was

751
00:28:59,760 --> 00:29:01,600
5 and it's nicely highlighted the

752
00:29:01,600 --> 00:29:03,279
register that's changed

753
00:29:03,279 --> 00:29:05,679
here and we can just keep remember if we

754
00:29:05,679 --> 00:29:07,679
if we push enter we get the

755
00:29:07,679 --> 00:29:09,679
most recently executed instructions so

756
00:29:09,679 --> 00:29:10,960
we can go through

757
00:29:10,960 --> 00:29:13,440
all right we set a0 to 0 and now we can

758
00:29:13,440 --> 00:29:15,120
just kind of watch ourselves go through

759
00:29:15,120 --> 00:29:16,399
this loop

760
00:29:16,399 --> 00:29:19,919
and sum up the values

761
00:29:19,919 --> 00:29:21,760
and again this is like a complete you

762
00:29:21,760 --> 00:29:23,440
know toy function

763
00:29:23,440 --> 00:29:26,320
and then we can continue and you know

764
00:29:26,320 --> 00:29:27,600
live our lives and if you're ever

765
00:29:27,600 --> 00:29:29,760
curious about

766
00:29:29,760 --> 00:29:31,760
what kind of breakpoints you've set or

767
00:29:31,760 --> 00:29:34,000
you lose track of what you were doing

768
00:29:34,000 --> 00:29:38,080
if you type info break or break points

769
00:29:38,080 --> 00:29:39,919
you can see all of the breakpoints that

770
00:29:39,919 --> 00:29:41,360
you've set in your code

771
00:29:41,360 --> 00:29:43,279
and you can even see okay this

772
00:29:43,279 --> 00:29:45,520
breakpoint has already been hit one time

773
00:29:45,520 --> 00:29:47,840
and you get lots of useful information

774
00:29:47,840 --> 00:29:49,600
doing that

775
00:29:49,600 --> 00:29:51,520
if you don't want to have the register

776
00:29:51,520 --> 00:29:53,360
window but you do want to look at the

777
00:29:53,360 --> 00:29:54,799
registers

778
00:29:54,799 --> 00:29:58,240
info reg or info registers or ireg or

779
00:29:58,240 --> 00:29:59,279
any of the

780
00:29:59,279 --> 00:30:02,320
numerous gdb shortenings

781
00:30:02,320 --> 00:30:03,840
will bring up the register window as

782
00:30:03,840 --> 00:30:05,919
well

783
00:30:05,919 --> 00:30:08,320
um so with that is there any are there

784
00:30:08,320 --> 00:30:09,360
any questions about

785
00:30:09,360 --> 00:30:12,480
gdd um simple ones i know it's been

786
00:30:12,480 --> 00:30:14,880
um there's been lots of post sump shots

787
00:30:14,880 --> 00:30:15,919
about it so

788
00:30:15,919 --> 00:30:17,840
now is a good time to just ask uh some

789
00:30:17,840 --> 00:30:19,679
straightforward we'll i'll be showing

790
00:30:19,679 --> 00:30:20,640
more

791
00:30:20,640 --> 00:30:23,200
usage of ddb what command did you use to

792
00:30:23,200 --> 00:30:25,760
open the multiple windows so i use tmux

793
00:30:25,760 --> 00:30:28,880
so i can show just from scratch uh if we

794
00:30:28,880 --> 00:30:29,200
go

795
00:30:29,200 --> 00:30:31,679
here and i open a new terminal so here's

796
00:30:31,679 --> 00:30:33,760
just a blank terminal

797
00:30:33,760 --> 00:30:35,840
if you type tmux and this is available

798
00:30:35,840 --> 00:30:38,480
on athena

799
00:30:40,080 --> 00:30:41,600
i'll address the next question in a

800
00:30:41,600 --> 00:30:43,600
second so now i'm in tmux which you can

801
00:30:43,600 --> 00:30:44,720
tell by this

802
00:30:44,720 --> 00:30:47,919
green bar at the bottom and if you want

803
00:30:47,919 --> 00:30:48,399
to

804
00:30:48,399 --> 00:30:49,919
get so there's a couple ways you can do

805
00:30:49,919 --> 00:30:51,919
multiple windows in tebow tmux

806
00:30:51,919 --> 00:30:55,679
uh if you're so you can type control bc

807
00:30:55,679 --> 00:30:58,320
and uh i know that's sometimes if you're

808
00:30:58,320 --> 00:30:59,919
used to using emacs that will make a lot

809
00:30:59,919 --> 00:31:00,960
of sense but

810
00:31:00,960 --> 00:31:04,159
um normal people who don't use emacs

811
00:31:04,159 --> 00:31:06,799
that's hitting control and then d and

812
00:31:06,799 --> 00:31:07,600
then hitting

813
00:31:07,600 --> 00:31:09,840
c on its own afterwards that will get

814
00:31:09,840 --> 00:31:11,519
you a second window which you can then

815
00:31:11,519 --> 00:31:13,519
navigate between with control b

816
00:31:13,519 --> 00:31:16,640
and then p control b and then n to go

817
00:31:16,640 --> 00:31:17,760
previous and next

818
00:31:17,760 --> 00:31:19,360
yeah and david just posted a t-much

819
00:31:19,360 --> 00:31:21,279
cheat sheet which is useful

820
00:31:21,279 --> 00:31:22,880
and if you want to split the windows i

821
00:31:22,880 --> 00:31:24,320
think it's ctrl b and then

822
00:31:24,320 --> 00:31:28,000
the percent sign will split them um

823
00:31:28,000 --> 00:31:30,559
vertically and then sing a double

824
00:31:30,559 --> 00:31:31,279
control b

825
00:31:31,279 --> 00:31:34,000
and then double quote we'll split them

826
00:31:34,000 --> 00:31:35,840
uh horizontally

827
00:31:35,840 --> 00:31:37,120
and so that's how we get them and if

828
00:31:37,120 --> 00:31:39,120
we're in this state we can use control b

829
00:31:39,120 --> 00:31:42,880
and o to jump between our windows

830
00:31:42,880 --> 00:31:44,720
so that's what's that's how i got the

831
00:31:44,720 --> 00:31:46,640
multiple windows yeah i don't care

832
00:31:46,640 --> 00:31:49,840
um and then ahmed asked

833
00:31:49,840 --> 00:31:51,200
why is this displaying assembly

834
00:31:51,200 --> 00:31:52,960
addresses again instead of c line

835
00:31:52,960 --> 00:31:53,760
numbers

836
00:31:53,760 --> 00:31:57,919
ah so because the the function

837
00:31:57,919 --> 00:32:00,240
so if we go back to the assembly

838
00:32:00,240 --> 00:32:00,960
function

839
00:32:00,960 --> 00:32:02,880
this is implemented entirely in assembly

840
00:32:02,880 --> 00:32:04,320
and not at all in c

841
00:32:04,320 --> 00:32:06,000
and so there just aren't any associated

842
00:32:06,000 --> 00:32:07,840
c line numbers for this

843
00:32:07,840 --> 00:32:10,960
um if we were to

844
00:32:10,960 --> 00:32:14,000
set a breakpoint so if you type delete

845
00:32:14,000 --> 00:32:16,399
you'll delete all your breakpoints uh so

846
00:32:16,399 --> 00:32:18,640
i cleared the old one if i now set a

847
00:32:18,640 --> 00:32:19,679
breakpoint in

848
00:32:19,679 --> 00:32:22,240
demo one so that's a c breakpoint and

849
00:32:22,240 --> 00:32:23,600
continue

850
00:32:23,600 --> 00:32:26,240
and run this now if i go here and type

851
00:32:26,240 --> 00:32:27,360
layout split

852
00:32:27,360 --> 00:32:30,559
i'll get the c and the assembly um or if

853
00:32:30,559 --> 00:32:31,519
i just want the c

854
00:32:31,519 --> 00:32:33,120
source i can do layout source and i'll

855
00:32:33,120 --> 00:32:35,440
just get the c

856
00:32:35,440 --> 00:32:37,120
so that's uh that's what's going on it's

857
00:32:37,120 --> 00:32:39,279
just a quirk of the fact that this

858
00:32:39,279 --> 00:32:41,120
doesn't have associated c code and so we

859
00:32:41,120 --> 00:32:44,399
don't see seedline numbers

860
00:32:46,240 --> 00:32:49,600
any other any other questions about gdb

861
00:32:49,600 --> 00:32:53,120
tmox and that that sort of thing

862
00:32:53,120 --> 00:32:55,120
so layout split is the one that you use

863
00:32:55,120 --> 00:32:57,279
to bring up this extra window of the

864
00:32:57,279 --> 00:32:59,200
source and assembly and so on right

865
00:32:59,200 --> 00:33:02,240
yes yes so layout uh if you do layout

866
00:33:02,240 --> 00:33:03,600
split that'll get you

867
00:33:03,600 --> 00:33:05,600
source and assembly layout source will

868
00:33:05,600 --> 00:33:06,640
get you just source

869
00:33:06,640 --> 00:33:08,960
asm we'll get you just assembly and the

870
00:33:08,960 --> 00:33:10,480
registers are their own thing where if

871
00:33:10,480 --> 00:33:11,679
you type layout reg

872
00:33:11,679 --> 00:33:13,840
i think yeah that'll bring up the

873
00:33:13,840 --> 00:33:15,279
registers but

874
00:33:15,279 --> 00:33:17,679
unfortunately i don't know of a way to

875
00:33:17,679 --> 00:33:18,640
get

876
00:33:18,640 --> 00:33:20,399
the register of the assembly and the c

877
00:33:20,399 --> 00:33:22,159
code all at the same time outside of

878
00:33:22,159 --> 00:33:24,960
using inforeg with layout split

879
00:33:24,960 --> 00:33:28,159
i have a question um so when we set the

880
00:33:28,159 --> 00:33:31,440
break point uh add a line right it

881
00:33:31,440 --> 00:33:34,559
displays the address of the like in this

882
00:33:34,559 --> 00:33:36,000
case break point to add

883
00:33:36,000 --> 00:33:39,279
0x 354. um

884
00:33:39,279 --> 00:33:42,080
what any instruction might have multiple

885
00:33:42,080 --> 00:33:42,559
uh

886
00:33:42,559 --> 00:33:45,519
any like line of code in c might have

887
00:33:45,519 --> 00:33:46,960
multiple instructions

888
00:33:46,960 --> 00:33:49,440
so which one does its uh show i believe

889
00:33:49,440 --> 00:33:51,519
it shows the first one

890
00:33:51,519 --> 00:33:54,240
and uh it's to you for the person who

891
00:33:54,240 --> 00:33:54,799
asked to

892
00:33:54,799 --> 00:33:58,000
start the tui it's i think it's tui

893
00:33:58,000 --> 00:34:03,600
enable not enable to ui sorry i think

894
00:34:08,399 --> 00:34:10,879
um yeah again there's like a hundred

895
00:34:10,879 --> 00:34:13,280
cheat sheets out here for gdb

896
00:34:13,280 --> 00:34:15,520
and for tmux as well so if you ever find

897
00:34:15,520 --> 00:34:16,480
yourself lost

898
00:34:16,480 --> 00:34:21,440
i t gdp even has its own inbuilt um

899
00:34:21,440 --> 00:34:24,000
its own thing called apropos so if you

900
00:34:24,000 --> 00:34:25,520
look for apropos

901
00:34:25,520 --> 00:34:28,560
tui it will actually show you all of the

902
00:34:28,560 --> 00:34:33,440
commands that involve tui

903
00:34:33,440 --> 00:34:36,320
so yeah uh this can be quite useful but

904
00:34:36,320 --> 00:34:38,719
it can also be a little bit overwhelming

905
00:34:38,719 --> 00:34:41,839
um if you do apropos dash b it'll give

906
00:34:41,839 --> 00:34:44,560
you even more information i think

907
00:34:44,560 --> 00:34:48,399
um i don't remember i i don't use it

908
00:34:48,399 --> 00:34:50,079
often myself but if you if you do

909
00:34:50,079 --> 00:34:52,239
find or if you forget the exact way to

910
00:34:52,239 --> 00:34:54,079
type the command in in gdb and you don't

911
00:34:54,079 --> 00:34:56,000
feel like googling it apropos

912
00:34:56,000 --> 00:34:58,000
will will uh often be able to find

913
00:34:58,000 --> 00:34:59,359
exactly what you're looking for in

914
00:34:59,359 --> 00:35:00,720
addition to a whole bunch of stuff you

915
00:35:00,720 --> 00:35:02,240
weren't looking for

916
00:35:02,240 --> 00:35:05,280
um yeah so

917
00:35:05,280 --> 00:35:06,800
that can be quite useful gdp is

918
00:35:06,800 --> 00:35:08,480
extremely well documented as well

919
00:35:08,480 --> 00:35:11,040
so um yeah if you ever find yourself

920
00:35:11,040 --> 00:35:12,079
lost

921
00:35:12,079 --> 00:35:16,720
you know google is your friend um

922
00:35:16,720 --> 00:35:18,720
so now that we we've kind of been over

923
00:35:18,720 --> 00:35:20,160
assembly and

924
00:35:20,160 --> 00:35:22,960
and risk five and these sort of things i

925
00:35:22,960 --> 00:35:24,480
want to dive a little bit more into the

926
00:35:24,480 --> 00:35:25,760
specifics

927
00:35:25,760 --> 00:35:28,480
um of what you you really need to know

928
00:35:28,480 --> 00:35:29,599
for the

929
00:35:29,599 --> 00:35:32,320
lab coming up and also is this will be a

930
00:35:32,320 --> 00:35:33,839
little bit of review from the document

931
00:35:33,839 --> 00:35:34,640
that you've all

932
00:35:34,640 --> 00:35:37,040
of course as diligent students read

933
00:35:37,040 --> 00:35:38,880
through thoroughly

934
00:35:38,880 --> 00:35:42,839
uh in preparation for this lecture

935
00:35:42,839 --> 00:35:45,680
um so you know this table will of course

936
00:35:45,680 --> 00:35:47,839
be uh wildly familiar to you all

937
00:35:47,839 --> 00:35:51,119
and uh from from both double o4

938
00:35:51,119 --> 00:35:53,119
and from what you've read and this is

939
00:35:53,119 --> 00:35:55,280
the table of registers and

940
00:35:55,280 --> 00:35:58,720
registers are little you know locations

941
00:35:58,720 --> 00:36:02,800
on the cpu or on the processor

942
00:36:02,800 --> 00:36:05,440
pre-defined that it can use to store

943
00:36:05,440 --> 00:36:06,400
values

944
00:36:06,400 --> 00:36:08,640
and this is important because assembly

945
00:36:08,640 --> 00:36:09,520
operations

946
00:36:09,520 --> 00:36:11,520
if we remember from the assembly code

947
00:36:11,520 --> 00:36:14,079
the assembly doesn't operate on memory

948
00:36:14,079 --> 00:36:16,079
it operates on registers so when we do

949
00:36:16,079 --> 00:36:17,520
add when we do subtract

950
00:36:17,520 --> 00:36:20,960
we're operating on registers um

951
00:36:20,960 --> 00:36:22,800
and so what you'll often see as the

952
00:36:22,800 --> 00:36:24,160
pattern for

953
00:36:24,160 --> 00:36:26,079
for writing assembly is we'll have some

954
00:36:26,079 --> 00:36:27,520
kind of a load

955
00:36:27,520 --> 00:36:30,960
so we'll load some value

956
00:36:30,960 --> 00:36:34,640
to a register and that value can be from

957
00:36:34,640 --> 00:36:35,119
memory

958
00:36:35,119 --> 00:36:38,320
or it can be from another uh register

959
00:36:38,320 --> 00:36:40,560
and and here i'm referring to load in

960
00:36:40,560 --> 00:36:42,320
general not the load instruction

961
00:36:42,320 --> 00:36:45,760
um and then we'll operate

962
00:36:45,760 --> 00:36:48,640
so we'll perform some operation on the

963
00:36:48,640 --> 00:36:49,359
register

964
00:36:49,359 --> 00:36:50,880
and then if we care about the result of

965
00:36:50,880 --> 00:36:52,560
that operation outside of the return

966
00:36:52,560 --> 00:36:53,359
address

967
00:36:53,359 --> 00:36:56,880
we will um will store that

968
00:36:56,880 --> 00:37:00,480
register to somewhere

969
00:37:00,480 --> 00:37:02,000
to some locate that will store that

970
00:37:02,000 --> 00:37:04,000
register to some location

971
00:37:04,000 --> 00:37:08,160
do that in memory or to another register

972
00:37:08,160 --> 00:37:09,760
and so that's that's uh generally the

973
00:37:09,760 --> 00:37:11,760
way things work and and registers are

974
00:37:11,760 --> 00:37:14,000
the absolute fastest way to perform

975
00:37:14,000 --> 00:37:16,560
any sort of calculation uh or to access

976
00:37:16,560 --> 00:37:18,320
any value and that's why

977
00:37:18,320 --> 00:37:21,040
um it's important to use them and also

978
00:37:21,040 --> 00:37:21,760
why

979
00:37:21,760 --> 00:37:24,160
we prefer using registers over using

980
00:37:24,160 --> 00:37:26,079
memory so if you remember from

981
00:37:26,079 --> 00:37:28,400
the reading when we call functions so

982
00:37:28,400 --> 00:37:30,160
you can see here that registers

983
00:37:30,160 --> 00:37:33,839
a0 to 7 and

984
00:37:33,839 --> 00:37:35,839
in general when we speak about registers

985
00:37:35,839 --> 00:37:37,040
we

986
00:37:37,040 --> 00:37:39,040
we will be referring to them by their

987
00:37:39,040 --> 00:37:41,280
abi name um

988
00:37:41,280 --> 00:37:43,200
not only is it less confusing it's just

989
00:37:43,200 --> 00:37:44,560
a standard and it's also the way that

990
00:37:44,560 --> 00:37:46,079
you'll write assembly code

991
00:37:46,079 --> 00:37:49,440
um this you know these actual numbers

992
00:37:49,440 --> 00:37:51,119
are not super important

993
00:37:51,119 --> 00:37:54,400
the only case where it does matter is

994
00:37:54,400 --> 00:37:57,280
for the compressed version of risk 5

995
00:37:57,280 --> 00:37:58,320
instructions

996
00:37:58,320 --> 00:38:01,040
and if you want to know more about that

997
00:38:01,040 --> 00:38:02,720
feel free to read up about it the basic

998
00:38:02,720 --> 00:38:04,000
idea is that risk

999
00:38:04,000 --> 00:38:07,200
5 normal instructions are 64 bits

1000
00:38:07,200 --> 00:38:08,880
but there's also a compressed version in

1001
00:38:08,880 --> 00:38:10,800
which instructions are 16 bits

1002
00:38:10,800 --> 00:38:12,800
and we use less registers and the

1003
00:38:12,800 --> 00:38:14,800
registers we use in that case

1004
00:38:14,800 --> 00:38:17,520
are 8 through 15. those are the

1005
00:38:17,520 --> 00:38:19,200
registers that are available to us

1006
00:38:19,200 --> 00:38:20,800
so i think somebody had a question about

1007
00:38:20,800 --> 00:38:23,440
you know why is this s1 register

1008
00:38:23,440 --> 00:38:26,640
x9 why is it separated from all of the

1009
00:38:26,640 --> 00:38:27,200
other s

1010
00:38:27,200 --> 00:38:29,680
registers and my guess is that that's

1011
00:38:29,680 --> 00:38:31,839
why

1012
00:38:31,839 --> 00:38:33,119
that we separated from all of the other

1013
00:38:33,119 --> 00:38:34,880
ones because it's available

1014
00:38:34,880 --> 00:38:37,760
in compressed instruction mode whereas

1015
00:38:37,760 --> 00:38:40,079
s2 to 11 or not

1016
00:38:40,079 --> 00:38:41,839
and so that's the idea so that's that's

1017
00:38:41,839 --> 00:38:43,599
for compressed but outside of that

1018
00:38:43,599 --> 00:38:46,480
registers will always be referred to by

1019
00:38:46,480 --> 00:38:47,200
their

1020
00:38:47,200 --> 00:38:50,079
abi name and so a0 to a7 are used for

1021
00:38:50,079 --> 00:38:51,280
function arguments

1022
00:38:51,280 --> 00:38:52,640
but if we have a function that takes

1023
00:38:52,640 --> 00:38:55,119
more than the eight arguments that those

1024
00:38:55,119 --> 00:38:57,520
registers give us access to

1025
00:38:57,520 --> 00:39:00,000
we do need to use memory but that's this

1026
00:39:00,000 --> 00:39:01,200
is kind of an illustration of the fact

1027
00:39:01,200 --> 00:39:02,720
that we don't want to use memory when we

1028
00:39:02,720 --> 00:39:04,320
can use registers

1029
00:39:04,320 --> 00:39:07,200
we only we only use a memory if we have

1030
00:39:07,200 --> 00:39:08,720
to

1031
00:39:08,720 --> 00:39:10,800
and this uh this column here the saver

1032
00:39:10,800 --> 00:39:12,079
column

1033
00:39:12,079 --> 00:39:14,079
this is also extremely important when

1034
00:39:14,079 --> 00:39:16,240
we're discussing registers caller versus

1035
00:39:16,240 --> 00:39:17,839
callee saved

1036
00:39:17,839 --> 00:39:21,280
and um the terms are

1037
00:39:21,280 --> 00:39:24,000
i confuse them regularly caller and

1038
00:39:24,000 --> 00:39:26,160
callie they only differ by one letter

1039
00:39:26,160 --> 00:39:29,200
the easiest way that i found to remember

1040
00:39:29,200 --> 00:39:30,480
them is that

1041
00:39:30,480 --> 00:39:34,400
caller saved registers are not

1042
00:39:34,400 --> 00:39:37,119
preserved

1043
00:39:37,599 --> 00:39:42,240
across a function call

1044
00:39:42,240 --> 00:39:46,800
so and callee saved registers

1045
00:39:46,800 --> 00:39:52,079
are preserved what i mean by this

1046
00:39:52,079 --> 00:39:54,560
is that

1047
00:39:55,200 --> 00:39:58,079
a caller saved register can be

1048
00:39:58,079 --> 00:39:59,200
overwritten

1049
00:39:59,200 --> 00:40:02,320
by the function so let's say i have

1050
00:40:02,320 --> 00:40:03,040
function a

1051
00:40:03,040 --> 00:40:05,599
which calls function b any registers

1052
00:40:05,599 --> 00:40:07,119
being used by function a

1053
00:40:07,119 --> 00:40:10,319
that are caller saved call function b

1054
00:40:10,319 --> 00:40:12,720
can overwrite when it gets called and i

1055
00:40:12,720 --> 00:40:14,560
think a good illustration of this

1056
00:40:14,560 --> 00:40:17,359
is the return address because you know

1057
00:40:17,359 --> 00:40:19,040
you can see that the return address is

1058
00:40:19,040 --> 00:40:21,119
caller saved

1059
00:40:21,119 --> 00:40:23,119
and that's important because every

1060
00:40:23,119 --> 00:40:25,760
function needs to use the return address

1061
00:40:25,760 --> 00:40:28,640
so when a calls b it's important that b

1062
00:40:28,640 --> 00:40:30,079
be able to

1063
00:40:30,079 --> 00:40:32,000
overwrite the value in the return

1064
00:40:32,000 --> 00:40:34,400
address hence why it's caller saved

1065
00:40:34,400 --> 00:40:37,760
and callee saved registers are just our

1066
00:40:37,760 --> 00:40:40,079
convention that we use

1067
00:40:40,079 --> 00:40:42,160
the frame pointer is important for that

1068
00:40:42,160 --> 00:40:44,079
reason

1069
00:40:44,079 --> 00:40:45,680
and those are preserved across the

1070
00:40:45,680 --> 00:40:47,440
function calls so basically any register

1071
00:40:47,440 --> 00:40:49,040
that is caller saved

1072
00:40:49,040 --> 00:40:50,480
the function that is making the call

1073
00:40:50,480 --> 00:40:52,560
needs to worry about those registers

1074
00:40:52,560 --> 00:40:54,079
and if they're calling saved the

1075
00:40:54,079 --> 00:40:55,839
function that is being called

1076
00:40:55,839 --> 00:40:57,359
needs to worry about preserving the

1077
00:40:57,359 --> 00:40:59,760
value in those registers

1078
00:40:59,760 --> 00:41:02,720
and again you know i i regularly confuse

1079
00:41:02,720 --> 00:41:03,280
the two

1080
00:41:03,280 --> 00:41:07,760
and find myself returning to this table

1081
00:41:07,760 --> 00:41:11,119
to remind myself about what they do

1082
00:41:11,119 --> 00:41:14,160
and so you know you if you remember from

1083
00:41:14,160 --> 00:41:14,880
the reading

1084
00:41:14,880 --> 00:41:18,160
all of these registers are 64 bits wide

1085
00:41:18,160 --> 00:41:19,359
so they have 64

1086
00:41:19,359 --> 00:41:22,560
places where we can put things and

1087
00:41:22,560 --> 00:41:24,960
the various data types are made to fit

1088
00:41:24,960 --> 00:41:27,200
into those 64 bits

1089
00:41:27,200 --> 00:41:28,960
based on the calling convention so if we

1090
00:41:28,960 --> 00:41:30,720
have a 32-bit integer

1091
00:41:30,720 --> 00:41:32,319
depending on how it's whether or not

1092
00:41:32,319 --> 00:41:34,240
it's sign extended you know we'll either

1093
00:41:34,240 --> 00:41:36,160
add zeros or ones to the front of that

1094
00:41:36,160 --> 00:41:37,119
integer

1095
00:41:37,119 --> 00:41:38,880
in order to make it 64 bits to put in

1096
00:41:38,880 --> 00:41:40,480
these registers

1097
00:41:40,480 --> 00:41:42,800
so before we move on uh does anybody

1098
00:41:42,800 --> 00:41:44,720
have questions about

1099
00:41:44,720 --> 00:41:47,520
registers or things things of that

1100
00:41:47,520 --> 00:41:49,839
nature

1101
00:41:58,079 --> 00:42:01,119
i have a question can you have a

1102
00:42:01,119 --> 00:42:05,359
can you put a return value in a1

1103
00:42:05,359 --> 00:42:08,560
yes it's a good question so um i think

1104
00:42:08,560 --> 00:42:09,440
in theory

1105
00:42:09,440 --> 00:42:14,560
you can the reason why we say a0 to a1

1106
00:42:14,560 --> 00:42:16,960
is if a function returns a long long

1107
00:42:16,960 --> 00:42:18,800
which is 128 bits

1108
00:42:18,800 --> 00:42:21,440
so if you remember from the reading if a

1109
00:42:21,440 --> 00:42:23,599
function argument is 100 is more than

1110
00:42:23,599 --> 00:42:26,079
a pointer word and so when we refer to

1111
00:42:26,079 --> 00:42:28,160
the prior word size we're saying 64 bits

1112
00:42:28,160 --> 00:42:29,760
so if we have something that is twice

1113
00:42:29,760 --> 00:42:32,319
the size of a pointer word

1114
00:42:32,319 --> 00:42:35,359
um we can put that in a register pair

1115
00:42:35,359 --> 00:42:37,520
and so the same convention holds true

1116
00:42:37,520 --> 00:42:39,280
for return addresses where if we have

1117
00:42:39,280 --> 00:42:40,160
something that's

1118
00:42:40,160 --> 00:42:42,800
the size of twice a pointer word we can

1119
00:42:42,800 --> 00:42:44,160
stick that in a0 and

1120
00:42:44,160 --> 00:42:46,400
a1 and use that as the return address i

1121
00:42:46,400 --> 00:42:47,839
think you'll run into problems if you

1122
00:42:47,839 --> 00:42:49,839
only try to put something in a1

1123
00:42:49,839 --> 00:42:52,800
make sense thanks

1124
00:42:55,839 --> 00:42:58,720
why are the registers not like

1125
00:42:58,720 --> 00:42:59,520
continuous

1126
00:42:59,520 --> 00:43:03,119
so why is like a zero and one separate

1127
00:43:03,119 --> 00:43:06,000
from sorry no that's a that's a bad

1128
00:43:06,000 --> 00:43:08,400
example what's why is s1

1129
00:43:08,400 --> 00:43:10,560
separate from s2 why are the a's in

1130
00:43:10,560 --> 00:43:13,119
between like is there any point in that

1131
00:43:13,119 --> 00:43:15,440
yeah so uh i mentioned this briefly

1132
00:43:15,440 --> 00:43:16,960
earlier but there is a

1133
00:43:16,960 --> 00:43:19,119
compressed this is a guess i don't i

1134
00:43:19,119 --> 00:43:20,319
don't know for sure

1135
00:43:20,319 --> 00:43:23,119
but there's a compressed version of the

1136
00:43:23,119 --> 00:43:23,920
risc 5

1137
00:43:23,920 --> 00:43:26,960
instructions which are 16 bits in size

1138
00:43:26,960 --> 00:43:28,960
as opposed to 64.

1139
00:43:28,960 --> 00:43:32,319
and you would use that to try and

1140
00:43:32,319 --> 00:43:34,480
make your code take less space in memory

1141
00:43:34,480 --> 00:43:36,720
and when you use those 16-bit

1142
00:43:36,720 --> 00:43:38,319
instructions you only have

1143
00:43:38,319 --> 00:43:42,079
accesses to registers 8 through 15.

1144
00:43:42,079 --> 00:43:46,000
so i think s1 is separate from s2 to 11

1145
00:43:46,000 --> 00:43:47,920
because they want to make it clear that

1146
00:43:47,920 --> 00:43:50,000
s1 is available to you

1147
00:43:50,000 --> 00:43:52,000
in the compressed instruction mode

1148
00:43:52,000 --> 00:43:54,560
whereas s2 to 11 aren't

1149
00:43:54,560 --> 00:43:56,800
um and the reason you know i don't know

1150
00:43:56,800 --> 00:43:58,480
why they picked x

1151
00:43:58,480 --> 00:44:01,680
x eight to 15 but i suspect that that's

1152
00:44:01,680 --> 00:44:03,040
just they looked at a bunch of code and

1153
00:44:03,040 --> 00:44:04,079
we're like oh these are the most

1154
00:44:04,079 --> 00:44:09,839
commonly used registers

1155
00:44:09,860 --> 00:44:12,929
[Music]

1156
00:44:17,119 --> 00:44:20,000
any other questions

1157
00:44:20,880 --> 00:44:24,880
i had a question um besides the frame

1158
00:44:24,880 --> 00:44:27,040
pointer the stack pointer and all

1159
00:44:27,040 --> 00:44:29,839
uh i i don't know why we would need more

1160
00:44:29,839 --> 00:44:30,560
call

1161
00:44:30,560 --> 00:44:33,599
callista registers but we do have

1162
00:44:33,599 --> 00:44:37,680
like a bunch of them yeah the s1s

1163
00:44:37,680 --> 00:44:40,560
to 11s those are just for i believe used

1164
00:44:40,560 --> 00:44:42,480
there for freedom for the compiler

1165
00:44:42,480 --> 00:44:45,359
or for the programmer to use um so there

1166
00:44:45,359 --> 00:44:46,800
are maybe there are certain cases where

1167
00:44:46,800 --> 00:44:47,520
you want

1168
00:44:47,520 --> 00:44:49,200
you want to guarantee that something is

1169
00:44:49,200 --> 00:44:50,960
still around

1170
00:44:50,960 --> 00:44:53,839
after after your function call the

1171
00:44:53,839 --> 00:44:55,839
compiler can choose to use

1172
00:44:55,839 --> 00:45:00,079
s1 211 to do that

1173
00:45:00,160 --> 00:45:02,720
i don't have like on hand a specific

1174
00:45:02,720 --> 00:45:04,720
example of where that's useful

1175
00:45:04,720 --> 00:45:07,920
but i'm sure it shows up where

1176
00:45:07,920 --> 00:45:11,839
having a callee save value is important

1177
00:45:14,319 --> 00:45:15,760
but these are basically basically you

1178
00:45:15,760 --> 00:45:17,440
know programmer or compiler's choice to

1179
00:45:17,440 --> 00:45:18,160
use

1180
00:45:18,160 --> 00:45:21,200
that's 1 to 11.

1181
00:45:22,400 --> 00:45:23,599
and i should note that these these

1182
00:45:23,599 --> 00:45:25,119
floating point registers they're for

1183
00:45:25,119 --> 00:45:27,040
floating point arithmetic

1184
00:45:27,040 --> 00:45:30,079
i as far as i'm aware you won't see them

1185
00:45:30,079 --> 00:45:31,680
in this class

1186
00:45:31,680 --> 00:45:33,359
and so you don't really need to worry

1187
00:45:33,359 --> 00:45:35,680
about them

1188
00:45:38,560 --> 00:45:41,839
okay so we started talking a little bit

1189
00:45:41,839 --> 00:45:45,440
about function calls

1190
00:45:45,440 --> 00:45:48,640
and so with that i want to

1191
00:45:48,640 --> 00:45:54,400
move us into discussion of the stack

1192
00:45:54,400 --> 00:45:57,839
so this is this is

1193
00:45:57,839 --> 00:46:01,040
we're talking about the stack and

1194
00:46:01,040 --> 00:46:03,920
the stack if you've seen it likely

1195
00:46:03,920 --> 00:46:04,560
before

1196
00:46:04,560 --> 00:46:07,440
the reason why the stack is important is

1197
00:46:07,440 --> 00:46:07,760
it

1198
00:46:07,760 --> 00:46:11,280
it's what keeps our functions

1199
00:46:11,280 --> 00:46:14,640
organized and sane and it's what allows

1200
00:46:14,640 --> 00:46:16,560
and what makes functions work it what

1201
00:46:16,560 --> 00:46:18,000
it's what makes return

1202
00:46:18,000 --> 00:46:21,040
work and it's also uh where often we'll

1203
00:46:21,040 --> 00:46:22,000
find ourselves

1204
00:46:22,000 --> 00:46:24,800
saving our registers and things like

1205
00:46:24,800 --> 00:46:26,839
that

1206
00:46:26,839 --> 00:46:29,440
um

1207
00:46:29,440 --> 00:46:32,720
so here i've

1208
00:46:32,720 --> 00:46:35,720
given just a pretty simple um

1209
00:46:35,720 --> 00:46:36,960
[Music]

1210
00:46:36,960 --> 00:46:39,839
layout of what a stack looks like and so

1211
00:46:39,839 --> 00:46:41,440
each of these

1212
00:46:41,440 --> 00:46:44,800
boxes here is what we refer to

1213
00:46:44,800 --> 00:46:49,040
as a stack frame

1214
00:46:49,040 --> 00:46:52,400
and every time we get

1215
00:46:52,400 --> 00:46:57,839
which are generated by function calls

1216
00:46:59,920 --> 00:47:03,280
um every time we call a function

1217
00:47:03,280 --> 00:47:06,319
that function makes for itself its own

1218
00:47:06,319 --> 00:47:07,680
stack frame

1219
00:47:07,680 --> 00:47:11,040
and which is in which it uses itself and

1220
00:47:11,040 --> 00:47:13,760
does that by moving around the stack

1221
00:47:13,760 --> 00:47:14,480
pointer

1222
00:47:14,480 --> 00:47:17,200
so here's the stack pointer and this is

1223
00:47:17,200 --> 00:47:17,839
uh

1224
00:47:17,839 --> 00:47:20,160
and it's very important to remember with

1225
00:47:20,160 --> 00:47:21,760
stacks

1226
00:47:21,760 --> 00:47:24,800
we start from high addresses

1227
00:47:24,800 --> 00:47:28,160
and we grow downwards to

1228
00:47:28,160 --> 00:47:30,720
low addresses so the stack grows down

1229
00:47:30,720 --> 00:47:32,160
always

1230
00:47:32,160 --> 00:47:34,400
and so you'll see that the arithmetic

1231
00:47:34,400 --> 00:47:36,240
for a stack pointer is uh

1232
00:47:36,240 --> 00:47:38,480
is usually done via subtraction when we

1233
00:47:38,480 --> 00:47:40,240
want to make a new stack frame

1234
00:47:40,240 --> 00:47:43,280
in assembly so the stack grows downwards

1235
00:47:43,280 --> 00:47:46,240
and stack frames for a function contain

1236
00:47:46,240 --> 00:47:48,960
saved registers local variables

1237
00:47:48,960 --> 00:47:51,520
um also like i like i was saying if you

1238
00:47:51,520 --> 00:47:52,000
run out

1239
00:47:52,000 --> 00:47:54,640
of argument registers additional

1240
00:47:54,640 --> 00:47:56,319
arguments will show up on the stack

1241
00:47:56,319 --> 00:47:58,160
and so not at stack frames are not all

1242
00:47:58,160 --> 00:47:59,440
the same size

1243
00:47:59,440 --> 00:48:00,800
even though they are in this diagram

1244
00:48:00,800 --> 00:48:02,640
that's not the case different functions

1245
00:48:02,640 --> 00:48:04,000
have different numbers of local

1246
00:48:04,000 --> 00:48:06,640
variables different safe registers

1247
00:48:06,640 --> 00:48:08,800
so on and so forth and so stack frames

1248
00:48:08,800 --> 00:48:10,480
will be different sizes but the two

1249
00:48:10,480 --> 00:48:12,800
things that you can definitely count on

1250
00:48:12,800 --> 00:48:14,960
which are important is that uh the

1251
00:48:14,960 --> 00:48:16,480
return address will always be

1252
00:48:16,480 --> 00:48:19,280
on the first thing and the frame pointer

1253
00:48:19,280 --> 00:48:21,119
the previous frames frame pointer is

1254
00:48:21,119 --> 00:48:23,200
also going to show up on the stack

1255
00:48:23,200 --> 00:48:26,640
at a predictable location so

1256
00:48:26,640 --> 00:48:29,280
the two important registers here are sp

1257
00:48:29,280 --> 00:48:30,720
which you know as we discussed

1258
00:48:30,720 --> 00:48:33,359
is used for this is the bottom of the

1259
00:48:33,359 --> 00:48:35,680
stack

1260
00:48:35,680 --> 00:48:38,240
or generally you know it's the location

1261
00:48:38,240 --> 00:48:39,280
of the stack

1262
00:48:39,280 --> 00:48:43,280
and then fp is our also important

1263
00:48:43,280 --> 00:48:46,319
register and this points to the top of

1264
00:48:46,319 --> 00:48:48,880
the current

1265
00:48:48,880 --> 00:48:52,480
frame and this is important because

1266
00:48:52,480 --> 00:48:54,800
that means that the return address and

1267
00:48:54,800 --> 00:48:56,240
the previous fp

1268
00:48:56,240 --> 00:48:59,599
will always be at a fixed location

1269
00:48:59,599 --> 00:49:02,720
from the current frame pointer so that

1270
00:49:02,720 --> 00:49:03,839
means that

1271
00:49:03,839 --> 00:49:06,000
if i want to find my return address or i

1272
00:49:06,000 --> 00:49:07,839
want to find the previous frame

1273
00:49:07,839 --> 00:49:10,640
i can always get to those values by

1274
00:49:10,640 --> 00:49:13,599
looking at the current frame pointer

1275
00:49:13,599 --> 00:49:15,520
and the reason why we store the previous

1276
00:49:15,520 --> 00:49:17,760
frame pointer is to allow us

1277
00:49:17,760 --> 00:49:19,760
to jump back so once this function

1278
00:49:19,760 --> 00:49:22,720
returns we can move this into fp

1279
00:49:22,720 --> 00:49:25,359
and all of a sudden fp again will go

1280
00:49:25,359 --> 00:49:26,559
from pointing to this

1281
00:49:26,559 --> 00:49:29,359
this stack frame to now pointing to this

1282
00:49:29,359 --> 00:49:30,319
stack frame

1283
00:49:30,319 --> 00:49:32,160
and so we use the frame pointer to

1284
00:49:32,160 --> 00:49:34,079
manipulate our stack frames

1285
00:49:34,079 --> 00:49:35,520
and make sure we're always pointing to

1286
00:49:35,520 --> 00:49:37,280
the one corresponding

1287
00:49:37,280 --> 00:49:40,960
to the correct function

1288
00:49:40,960 --> 00:49:42,880
and that's that's kind of how things uh

1289
00:49:42,880 --> 00:49:44,160
how things are done

1290
00:49:44,160 --> 00:49:47,839
and uh the these pieces of the stack

1291
00:49:47,839 --> 00:49:50,880
um need to be created by assembly

1292
00:49:50,880 --> 00:49:52,720
and so everything's everything in that

1293
00:49:52,720 --> 00:49:54,319
calling conventions

1294
00:49:54,319 --> 00:49:57,200
document that you read about that's all

1295
00:49:57,200 --> 00:49:59,359
um enforced by

1296
00:49:59,359 --> 00:50:01,040
effectively by the compiler so the

1297
00:50:01,040 --> 00:50:03,040
compiler adheres to

1298
00:50:03,040 --> 00:50:05,599
the calling convention and it's what

1299
00:50:05,599 --> 00:50:06,960
generates the stack frame

1300
00:50:06,960 --> 00:50:08,960
it generates the assembly code that

1301
00:50:08,960 --> 00:50:10,400
makes our stack frames look

1302
00:50:10,400 --> 00:50:13,200
correct so often at the top of a

1303
00:50:13,200 --> 00:50:15,280
function you'll see what's called

1304
00:50:15,280 --> 00:50:20,160
a function prolog

1305
00:50:21,280 --> 00:50:23,280
and then there will be the body of the

1306
00:50:23,280 --> 00:50:24,400
function

1307
00:50:24,400 --> 00:50:27,599
and then there will be an epilogue

1308
00:50:27,599 --> 00:50:30,240
that shows up after that so this is kind

1309
00:50:30,240 --> 00:50:31,920
of like

1310
00:50:31,920 --> 00:50:35,280
what an assembly uh

1311
00:50:35,280 --> 00:50:37,760
function will often look like and we'll

1312
00:50:37,760 --> 00:50:39,760
take a look at that

1313
00:50:39,760 --> 00:50:43,200
now so here i have another function

1314
00:50:43,200 --> 00:50:45,680
something so you you'll you'll note that

1315
00:50:45,680 --> 00:50:48,160
studently that sum2 did not have

1316
00:50:48,160 --> 00:50:50,559
any of these things that it it should if

1317
00:50:50,559 --> 00:50:52,079
it was a proper function

1318
00:50:52,079 --> 00:50:53,760
and this works fine because it's simple

1319
00:50:53,760 --> 00:50:55,200
enough so it does all of its

1320
00:50:55,200 --> 00:50:56,400
computations on

1321
00:50:56,400 --> 00:50:59,119
a0 and so things are things are good and

1322
00:50:59,119 --> 00:51:00,800
we're also not it's a it's a leaf

1323
00:51:00,800 --> 00:51:01,599
function

1324
00:51:01,599 --> 00:51:03,920
so you'll see if you see the term leaf

1325
00:51:03,920 --> 00:51:05,280
function that's a function that doesn't

1326
00:51:05,280 --> 00:51:06,960
call another function

1327
00:51:06,960 --> 00:51:08,880
and the functions are special in that

1328
00:51:08,880 --> 00:51:11,119
they don't need to

1329
00:51:11,119 --> 00:51:14,240
worry about saving their own return

1330
00:51:14,240 --> 00:51:15,040
address

1331
00:51:15,040 --> 00:51:17,440
or saving really any of the caller saved

1332
00:51:17,440 --> 00:51:18,720
registers

1333
00:51:18,720 --> 00:51:21,760
because they're going to they're not

1334
00:51:21,760 --> 00:51:23,200
going to make another function call so

1335
00:51:23,200 --> 00:51:24,319
they don't have to be

1336
00:51:24,319 --> 00:51:27,119
as careful some then double on the other

1337
00:51:27,119 --> 00:51:27,680
hand

1338
00:51:27,680 --> 00:51:29,839
is not a leaf function so you can see

1339
00:51:29,839 --> 00:51:31,440
here it calls

1340
00:51:31,440 --> 00:51:35,760
um sum2 and so it does need to include

1341
00:51:35,760 --> 00:51:36,480
that

1342
00:51:36,480 --> 00:51:39,200
that prolog and so we see here that we

1343
00:51:39,200 --> 00:51:40,160
are subtracting

1344
00:51:40,160 --> 00:51:42,880
16 from the stack pointer so we're

1345
00:51:42,880 --> 00:51:43,839
making space

1346
00:51:43,839 --> 00:51:46,559
on our stack we're storing the return

1347
00:51:46,559 --> 00:51:47,200
address

1348
00:51:47,200 --> 00:51:50,160
for something double on the stack and

1349
00:51:50,160 --> 00:51:52,319
then we make our call to sum2

1350
00:51:52,319 --> 00:51:53,839
and after that all this this function

1351
00:51:53,839 --> 00:51:55,599
does is it calls sum2 and then

1352
00:51:55,599 --> 00:51:59,119
doubles the result doubles the result

1353
00:51:59,119 --> 00:52:01,839
turned by some two and here you can see

1354
00:52:01,839 --> 00:52:02,400
the

1355
00:52:02,400 --> 00:52:05,920
epilog so we load the return address

1356
00:52:05,920 --> 00:52:08,960
back in to ra and

1357
00:52:08,960 --> 00:52:11,599
delete our stack frame and then jump out

1358
00:52:11,599 --> 00:52:13,760
of the function

1359
00:52:13,760 --> 00:52:16,160
and so we can run that to make sure it

1360
00:52:16,160 --> 00:52:19,839
does what we would expect

1361
00:52:20,640 --> 00:52:23,440
we can go here

1362
00:52:24,240 --> 00:52:27,599
we can run so if we run demo2 or demo

1363
00:52:27,599 --> 00:52:29,520
one we got a result of 15

1364
00:52:29,520 --> 00:52:31,200
for the sum and i'll tell you that demo

1365
00:52:31,200 --> 00:52:33,599
two just uh just calls something double

1366
00:52:33,599 --> 00:52:34,640
and indeed

1367
00:52:34,640 --> 00:52:38,000
you know it happily doubles the sum

1368
00:52:38,000 --> 00:52:41,200
returned by some two and

1369
00:52:41,200 --> 00:52:45,359
so a question i have for for anybody

1370
00:52:45,359 --> 00:52:48,480
what happens if we uh delete

1371
00:52:48,480 --> 00:52:52,240
this prologue and f so what happens

1372
00:52:52,240 --> 00:52:55,040
if we just have this as our function

1373
00:52:55,040 --> 00:52:56,559
something double can anybody predict

1374
00:52:56,559 --> 00:53:01,520
what's going to happen

1375
00:53:01,520 --> 00:53:03,119
i mean one thing is that some then

1376
00:53:03,119 --> 00:53:05,119
double wouldn't know

1377
00:53:05,119 --> 00:53:07,280
the return address that it should return

1378
00:53:07,280 --> 00:53:09,119
to so upon calling

1379
00:53:09,119 --> 00:53:12,000
sum to that's going to override the

1380
00:53:12,000 --> 00:53:13,280
return address to be

1381
00:53:13,280 --> 00:53:15,680
some then double so at the end of thumb

1382
00:53:15,680 --> 00:53:16,319
then double

1383
00:53:16,319 --> 00:53:18,000
it's not going to return to its original

1384
00:53:18,000 --> 00:53:19,440
call

1385
00:53:19,440 --> 00:53:22,319
yeah exactly um and we can see that

1386
00:53:22,319 --> 00:53:24,000
that's what happens

1387
00:53:24,000 --> 00:53:27,040
again so if we

1388
00:53:27,040 --> 00:53:31,119
exit out of this and we exit out of this

1389
00:53:31,119 --> 00:53:33,200
and we recompile with now with our

1390
00:53:33,200 --> 00:53:35,599
broken function

1391
00:53:35,599 --> 00:53:37,200
we can take a look at exactly what's

1392
00:53:37,200 --> 00:53:39,359
going to happen so we can actually

1393
00:53:39,359 --> 00:53:43,839
set our breakpoint for something double

1394
00:53:45,280 --> 00:53:49,440
and set up tui and let it continue so if

1395
00:53:49,440 --> 00:53:50,880
we now run demo 2

1396
00:53:50,880 --> 00:53:54,240
okay we're at some then double and

1397
00:53:54,240 --> 00:53:56,319
again this is an assembly only function

1398
00:53:56,319 --> 00:53:58,640
so we're going to want to look at it in

1399
00:53:58,640 --> 00:54:02,640
assembly so we'll do layout asm layout

1400
00:54:02,640 --> 00:54:04,400
reg because it's important what's in the

1401
00:54:04,400 --> 00:54:06,559
registers in this case

1402
00:54:06,559 --> 00:54:08,240
and you'll see that gdb knows a whole

1403
00:54:08,240 --> 00:54:10,000
bunch of extra information

1404
00:54:10,000 --> 00:54:13,359
and so we can see that

1405
00:54:14,720 --> 00:54:16,720
we can see that ra currently so the

1406
00:54:16,720 --> 00:54:19,440
return address currently points to demo2

1407
00:54:19,440 --> 00:54:22,480
the plus 18 so

1408
00:54:22,480 --> 00:54:24,240
it points effectively into the function

1409
00:54:24,240 --> 00:54:26,160
demo2

1410
00:54:26,160 --> 00:54:29,680
and now we can run um we can just kind

1411
00:54:29,680 --> 00:54:31,440
of step through our function and see

1412
00:54:31,440 --> 00:54:35,760
what happens so we've called sum2

1413
00:54:35,760 --> 00:54:37,359
and immediately we can see that the

1414
00:54:37,359 --> 00:54:39,280
return address was

1415
00:54:39,280 --> 00:54:42,000
overwritten by sum 2 to now point to sum

1416
00:54:42,000 --> 00:54:43,359
then double plus 4

1417
00:54:43,359 --> 00:54:44,640
which makes sense you know that's what

1418
00:54:44,640 --> 00:54:46,960
we'd expect if we go back into our code

1419
00:54:46,960 --> 00:54:48,319
we call sum 2

1420
00:54:48,319 --> 00:54:52,720
and so sum2 should return to uh to here

1421
00:54:52,720 --> 00:54:54,670
and now we can step through

1422
00:54:54,670 --> 00:54:55,920
[Music]

1423
00:54:55,920 --> 00:54:59,280
you know so on up and uh

1424
00:54:59,280 --> 00:55:02,640
then we get back into

1425
00:55:05,359 --> 00:55:08,960
whoops the wrong s

1426
00:55:14,480 --> 00:55:16,400
okay so now we're here and now when sum

1427
00:55:16,400 --> 00:55:18,000
then double returns

1428
00:55:18,000 --> 00:55:21,119
as exactly as amir pointed out um its

1429
00:55:21,119 --> 00:55:23,040
return it has not restored its own

1430
00:55:23,040 --> 00:55:24,240
return address

1431
00:55:24,240 --> 00:55:26,079
and instead its return address is still

1432
00:55:26,079 --> 00:55:28,000
the one that was used by

1433
00:55:28,000 --> 00:55:31,760
um sum two and so we will

1434
00:55:31,760 --> 00:55:34,880
get into an infinite loop where we just

1435
00:55:34,880 --> 00:55:37,280
keep doing this over and over and over

1436
00:55:37,280 --> 00:55:39,839
again and we'll never terminate from it

1437
00:55:39,839 --> 00:55:42,079
and so this is a i think this is a good

1438
00:55:42,079 --> 00:55:44,000
illustration of why it's important to

1439
00:55:44,000 --> 00:55:46,240
keep track of our caller versus callee

1440
00:55:46,240 --> 00:55:47,760
saved registers

1441
00:55:47,760 --> 00:55:49,200
and hopefully this also shows that you

1442
00:55:49,200 --> 00:55:51,760
can use kind of gdb to

1443
00:55:51,760 --> 00:55:54,720
debug these sorts of these sorts of

1444
00:55:54,720 --> 00:55:55,920
problems so let's

1445
00:55:55,920 --> 00:55:59,040
restore what we had and we'll go

1446
00:55:59,040 --> 00:56:04,240
into some other demos to talk about

1447
00:56:04,240 --> 00:56:07,280
to illustrate uh somebody asked why are

1448
00:56:07,280 --> 00:56:08,880
we subtracting 16

1449
00:56:08,880 --> 00:56:11,280
that's to put space to get our stack

1450
00:56:11,280 --> 00:56:12,079
frame

1451
00:56:12,079 --> 00:56:15,359
so this is subtracting 16 from the stack

1452
00:56:15,359 --> 00:56:17,359
pointer so it's moving it down basically

1453
00:56:17,359 --> 00:56:18,480
in memory

1454
00:56:18,480 --> 00:56:21,119
um moving it down so that we now have

1455
00:56:21,119 --> 00:56:22,720
space for our own stack frame and then

1456
00:56:22,720 --> 00:56:24,240
we can stick stuff there

1457
00:56:24,240 --> 00:56:27,040
so because uh at this point in fact we

1458
00:56:27,040 --> 00:56:28,400
don't want to override what's at the

1459
00:56:28,400 --> 00:56:30,319
stack pointer uh

1460
00:56:30,319 --> 00:56:33,760
why not four is just um

1461
00:56:33,760 --> 00:56:36,720
well four

1462
00:56:36,799 --> 00:56:39,040
we need to do 16 because instructions

1463
00:56:39,040 --> 00:56:42,240
are 64.

1464
00:56:42,839 --> 00:56:45,520
uh yeah i guess i guess we wouldn't

1465
00:56:45,520 --> 00:56:48,799
don't actually need to do 16 but that's

1466
00:56:48,799 --> 00:56:51,040
generally what you'll see

1467
00:56:51,040 --> 00:56:52,960
um you'll generally just see i don't

1468
00:56:52,960 --> 00:56:54,400
think yeah

1469
00:56:54,400 --> 00:56:56,480
you you can't you can't do four because

1470
00:56:56,480 --> 00:56:58,720
uh you need eight so four doesn't work

1471
00:56:58,720 --> 00:56:59,599
but i think you can do

1472
00:56:59,599 --> 00:57:03,200
uh you need the instruction size

1473
00:57:03,200 --> 00:57:04,640
and the size of the register right so

1474
00:57:04,640 --> 00:57:06,240
registers are 64.

1475
00:57:06,240 --> 00:57:08,079
yeah and then so the convention why you

1476
00:57:08,079 --> 00:57:10,160
usually see 16 is because if we jump

1477
00:57:10,160 --> 00:57:11,440
back to our document

1478
00:57:11,440 --> 00:57:13,359
usually we have the return address and

1479
00:57:13,359 --> 00:57:14,559
the frame pointer

1480
00:57:14,559 --> 00:57:17,359
uh but we're not doing that here because

1481
00:57:17,359 --> 00:57:19,040
we're being uh

1482
00:57:19,040 --> 00:57:22,160
not super careful with our assembly

1483
00:57:22,160 --> 00:57:25,440
so normally if we if we look in

1484
00:57:25,440 --> 00:57:27,520
i'm sure if we look in kernel.asm we'll

1485
00:57:27,520 --> 00:57:28,960
see

1486
00:57:28,960 --> 00:57:32,000
yeah so if we look in kernel. we see

1487
00:57:32,000 --> 00:57:33,680
it's also you know 16 this is generally

1488
00:57:33,680 --> 00:57:36,960
what you'll see with the compiler

1489
00:57:38,000 --> 00:57:41,200
um okay so

1490
00:57:41,200 --> 00:57:46,640
now we can go back to this

1491
00:57:46,799 --> 00:57:49,280
fixed our function and now we can look

1492
00:57:49,280 --> 00:57:51,680
at some c

1493
00:57:52,839 --> 00:57:54,559
code

1494
00:57:54,559 --> 00:57:57,760
all right so here we have demo four

1495
00:57:57,760 --> 00:58:01,359
which is just basically um a copy of a

1496
00:58:01,359 --> 00:58:02,160
main function

1497
00:58:02,160 --> 00:58:05,520
like a imitation of the main function

1498
00:58:05,520 --> 00:58:08,960
so we have our args

1499
00:58:08,960 --> 00:58:11,680
which is an array of strings and we have

1500
00:58:11,680 --> 00:58:13,440
dummy main which takes

1501
00:58:13,440 --> 00:58:15,680
uh the number of arguments and the

1502
00:58:15,680 --> 00:58:16,799
arguments frame

1503
00:58:16,799 --> 00:58:20,079
and just prints it out um for us

1504
00:58:20,079 --> 00:58:21,680
and so that's all that's that's all

1505
00:58:21,680 --> 00:58:23,200
that's happening here it's pretty

1506
00:58:23,200 --> 00:58:24,640
straightforward

1507
00:58:24,640 --> 00:58:27,920
uh if we set a breakpoint in

1508
00:58:27,920 --> 00:58:30,559
dummy main

1509
00:58:31,200 --> 00:58:35,520
and we pop over let this

1510
00:58:35,520 --> 00:58:38,640
okay we let this continue and we we

1511
00:58:38,640 --> 00:58:39,359
start this

1512
00:58:39,359 --> 00:58:42,079
we run down four okay so we now we've

1513
00:58:42,079 --> 00:58:42,880
hit

1514
00:58:42,880 --> 00:58:46,240
um dummy main and there's a couple of uh

1515
00:58:46,240 --> 00:58:51,440
important things to uh remember about

1516
00:58:51,440 --> 00:58:53,680
uh that you can use gdp for regarding

1517
00:58:53,680 --> 00:58:54,559
stack frames

1518
00:58:54,559 --> 00:58:58,240
so if we type i so again that's info

1519
00:58:58,240 --> 00:59:00,559
if we type iframe we can see a whole

1520
00:59:00,559 --> 00:59:01,520
bunch of uh

1521
00:59:01,520 --> 00:59:03,839
useful information about the current

1522
00:59:03,839 --> 00:59:04,799
stack frame

1523
00:59:04,799 --> 00:59:06,720
so we can see we're at stack level zero

1524
00:59:06,720 --> 00:59:08,079
level zero means

1525
00:59:08,079 --> 00:59:10,480
it's uh earth is down in the call stack

1526
00:59:10,480 --> 00:59:12,000
that we can go

1527
00:59:12,000 --> 00:59:15,599
and the frame is at this address

1528
00:59:15,599 --> 00:59:18,000
the program counter which is okay that's

1529
00:59:18,000 --> 00:59:19,200
all well and good

1530
00:59:19,200 --> 00:59:22,079
we have a save program counter as well

1531
00:59:22,079 --> 00:59:22,720
and if we

1532
00:59:22,720 --> 00:59:25,359
again if we take this address and we

1533
00:59:25,359 --> 00:59:26,000
jump

1534
00:59:26,000 --> 00:59:28,330
into kernel.asm

1535
00:59:28,330 --> 00:59:29,680
[Music]

1536
00:59:29,680 --> 00:59:32,000
and we search for that address we can

1537
00:59:32,000 --> 00:59:33,200
indeed see

1538
00:59:33,200 --> 00:59:38,400
that that address is inside of

1539
00:59:38,400 --> 00:59:40,799
inside of demo form which is exactly

1540
00:59:40,799 --> 00:59:42,240
where we expect

1541
00:59:42,240 --> 00:59:45,760
the program to return to and it was

1542
00:59:45,760 --> 00:59:48,640
called by a frame at this address source

1543
00:59:48,640 --> 00:59:49,520
language c

1544
00:59:49,520 --> 00:59:51,839
you know that's that's nice to know and

1545
00:59:51,839 --> 00:59:53,680
then we have the argument list

1546
00:59:53,680 --> 00:59:57,040
also starts at this address of course

1547
00:59:57,040 --> 00:59:59,119
in this case we have most of our

1548
00:59:59,119 --> 01:00:00,240
arguments in

1549
01:00:00,240 --> 01:00:03,119
registers uh and then we can even see

1550
01:00:03,119 --> 01:00:03,440
what

1551
01:00:03,440 --> 01:00:06,880
args are we mean rxc is three

1552
01:00:06,880 --> 01:00:10,400
and rv is this address

1553
01:00:10,400 --> 01:00:13,520
and if we want to more in depth examine

1554
01:00:13,520 --> 01:00:15,680
things we can look at things like

1555
01:00:15,680 --> 01:00:19,119
info arcs which will tell us information

1556
01:00:19,119 --> 01:00:21,359
about the arguments of the function

1557
01:00:21,359 --> 01:00:25,200
we can look at but more importantly

1558
01:00:25,200 --> 01:00:28,559
we can type if we type back trace or bt

1559
01:00:28,559 --> 01:00:30,079
works as well

1560
01:00:30,079 --> 01:00:34,000
we get a full back trace of all of the

1561
01:00:34,000 --> 01:00:37,040
stacks uh the all of the stack frames

1562
01:00:37,040 --> 01:00:38,960
from the call stack so you can see you

1563
01:00:38,960 --> 01:00:40,240
know something questionable happened

1564
01:00:40,240 --> 01:00:42,000
here that's when we invoked a system

1565
01:00:42,000 --> 01:00:44,880
call um then we get to the user track

1566
01:00:44,880 --> 01:00:45,599
function

1567
01:00:45,599 --> 01:00:48,000
then to the syscall function then to

1568
01:00:48,000 --> 01:00:49,280
sysdemo

1569
01:00:49,280 --> 01:00:52,480
then to demo four and then finally to

1570
01:00:52,480 --> 01:00:54,160
dummy main

1571
01:00:54,160 --> 01:00:56,079
and if we want to investigate any of

1572
01:00:56,079 --> 01:00:57,359
these stack frames

1573
01:00:57,359 --> 01:01:00,240
more in depth we can do frame and then

1574
01:01:00,240 --> 01:01:01,599
whatever number

1575
01:01:01,599 --> 01:01:03,760
uh is along the side here so let's say i

1576
01:01:03,760 --> 01:01:05,839
want to look at what was my stack frame

1577
01:01:05,839 --> 01:01:07,680
when six calls are called i can go to

1578
01:01:07,680 --> 01:01:10,000
frame three and so now i'm

1579
01:01:10,000 --> 01:01:11,920
inside of gdb i'm looking at that stack

1580
01:01:11,920 --> 01:01:13,839
frame so if i type info frame

1581
01:01:13,839 --> 01:01:16,559
i can get this and here we get a lot

1582
01:01:16,559 --> 01:01:17,119
more

1583
01:01:17,119 --> 01:01:19,119
a lot more information we have a bunch

1584
01:01:19,119 --> 01:01:22,400
of saved registers

1585
01:01:22,400 --> 01:01:25,280
we have some local variables we don't

1586
01:01:25,280 --> 01:01:27,520
have any arguments to this function

1587
01:01:27,520 --> 01:01:29,280
we can see where the program counter

1588
01:01:29,280 --> 01:01:31,200
where we're supposed to jump back to

1589
01:01:31,200 --> 01:01:32,960
um all kinds of things like that so this

1590
01:01:32,960 --> 01:01:34,640
is super super useful for

1591
01:01:34,640 --> 01:01:36,160
if you're debugging things and in fact

1592
01:01:36,160 --> 01:01:38,559
it's so useful we make you implement

1593
01:01:38,559 --> 01:01:41,599
um your own version not nowhere near and

1594
01:01:41,599 --> 01:01:41,839
as

1595
01:01:41,839 --> 01:01:44,960
in depth as what udb tells you but we're

1596
01:01:44,960 --> 01:01:46,720
one of the exercises on the next lab

1597
01:01:46,720 --> 01:01:48,640
will be to implement your own

1598
01:01:48,640 --> 01:01:51,200
backtrace helper function for use when

1599
01:01:51,200 --> 01:01:54,000
debugging things inside the lab

1600
01:01:54,000 --> 01:01:56,079
and so back back traces uh is quite

1601
01:01:56,079 --> 01:01:58,319
useful and then if we type frame 0 or we

1602
01:01:58,319 --> 01:01:59,359
go back to

1603
01:01:59,359 --> 01:02:02,880
where we were supposed to be

1604
01:02:02,880 --> 01:02:04,720
and if we want to investigate you

1605
01:02:04,720 --> 01:02:06,720
probably noticed it's not super helpful

1606
01:02:06,720 --> 01:02:09,280
you know rv is a string

1607
01:02:09,280 --> 01:02:11,039
as an array of strings and so we just

1608
01:02:11,039 --> 01:02:12,799
get a ref we just get a

1609
01:02:12,799 --> 01:02:15,039
an address for where that's actually

1610
01:02:15,039 --> 01:02:15,920
stored

1611
01:02:15,920 --> 01:02:17,359
and if we want to look at what's in

1612
01:02:17,359 --> 01:02:18,559
there there's a couple ways of doing

1613
01:02:18,559 --> 01:02:19,200
this

1614
01:02:19,200 --> 01:02:22,720
uh the easiest is uh if we type print p

1615
01:02:22,720 --> 01:02:26,160
is for print and then if we d

1616
01:02:26,160 --> 01:02:28,480
uh dereference the address so we go look

1617
01:02:28,480 --> 01:02:29,280
at what's at the

1618
01:02:29,280 --> 01:02:32,319
address we can do that and

1619
01:02:32,319 --> 01:02:35,119
you know as you would expect we get the

1620
01:02:35,119 --> 01:02:37,520
first element of that array because

1621
01:02:37,520 --> 01:02:39,760
when it tries to print a string it'll go

1622
01:02:39,760 --> 01:02:41,440
you know as c says it'll go in until it

1623
01:02:41,440 --> 01:02:43,039
hits the null character

1624
01:02:43,039 --> 01:02:44,720
so we get foo which is the first element

1625
01:02:44,720 --> 01:02:46,160
that array and if we want to get more

1626
01:02:46,160 --> 01:02:47,039
things

1627
01:02:47,039 --> 01:02:50,400
we can put in the length so if we do

1628
01:02:50,400 --> 01:02:51,680
and then a number it'll go up to a

1629
01:02:51,680 --> 01:02:53,839
certain index so then we can see

1630
01:02:53,839 --> 01:02:57,119
both of the strings here and

1631
01:02:57,119 --> 01:02:59,520
you know again gdb is quite smart so we

1632
01:02:59,520 --> 01:03:01,359
can even

1633
01:03:01,359 --> 01:03:03,839
use rxe to print out the whole argument

1634
01:03:03,839 --> 01:03:05,520
array

1635
01:03:05,520 --> 01:03:07,760
and so all of that information is

1636
01:03:07,760 --> 01:03:10,400
available to you

1637
01:03:10,400 --> 01:03:12,720
however you you want to get it so gdp is

1638
01:03:12,720 --> 01:03:14,799
a super powerful tool

1639
01:03:14,799 --> 01:03:17,200
why does gdb or sorry why does the

1640
01:03:17,200 --> 01:03:18,319
compiler sometimes

1641
01:03:18,319 --> 01:03:21,440
optimize out rg c

1642
01:03:21,440 --> 01:03:24,319
and rgb that has happened to be before

1643
01:03:24,319 --> 01:03:25,680
yeah uh that just means that the

1644
01:03:25,680 --> 01:03:28,160
compiler found a more efficient way

1645
01:03:28,160 --> 01:03:29,599
likely it just got rid of the variable

1646
01:03:29,599 --> 01:03:31,839
and it's doing all of its operations

1647
01:03:31,839 --> 01:03:34,480
um directly you know via regis it might

1648
01:03:34,480 --> 01:03:36,640
be doing all of its operations on a0 for

1649
01:03:36,640 --> 01:03:37,839
example

1650
01:03:37,839 --> 01:03:39,039
it might just be doing all of its

1651
01:03:39,039 --> 01:03:41,039
computations on the return address

1652
01:03:41,039 --> 01:03:42,640
it's pretty common to see something like

1653
01:03:42,640 --> 01:03:44,559
that if you um

1654
01:03:44,559 --> 01:03:46,319
if it's a variable that's not you know

1655
01:03:46,319 --> 01:03:47,599
100

1656
01:03:47,599 --> 01:03:50,319
necessary uh if you you know we don't

1657
01:03:50,319 --> 01:03:50,720
let

1658
01:03:50,720 --> 01:03:51,920
we don't give you control over the

1659
01:03:51,920 --> 01:03:53,440
compiler but if you ever find that in

1660
01:03:53,440 --> 01:03:54,480
your day-to-day

1661
01:03:54,480 --> 01:03:57,039
you can try setting the optimization

1662
01:03:57,039 --> 01:03:59,599
flag for the compiler to zero

1663
01:03:59,599 --> 01:04:01,920
um but even then you know the compiler

1664
01:04:01,920 --> 01:04:03,839
will do we'll do its we'll do some level

1665
01:04:03,839 --> 01:04:05,520
of optimization

1666
01:04:05,520 --> 01:04:08,799
uh your hand is raised yeah

1667
01:04:08,799 --> 01:04:12,160
um what's the address besides

1668
01:04:12,160 --> 01:04:14,319
that dollar one or dollar two you know

1669
01:04:14,319 --> 01:04:15,760
like before foo

1670
01:04:15,760 --> 01:04:18,960
or bar uh dollar this

1671
01:04:18,960 --> 01:04:21,359
yeah so what's that address is that the

1672
01:04:21,359 --> 01:04:22,319
address where

1673
01:04:22,319 --> 01:04:26,079
foo is probably yeah

1674
01:04:26,079 --> 01:04:28,319
but but then rv points to some other

1675
01:04:28,319 --> 01:04:30,799
address shouldn't those be the same

1676
01:04:30,799 --> 01:04:35,119
uh so our rv is on the stack

1677
01:04:35,119 --> 01:04:38,240
and it'll so the reason why

1678
01:04:38,240 --> 01:04:39,920
you know if you look at these addresses

1679
01:04:39,920 --> 01:04:41,680
we can see that they're in the kernel

1680
01:04:41,680 --> 01:04:44,720
uh just by the eight zero zero zero

1681
01:04:44,720 --> 01:04:47,520
um which makes sense because we they're

1682
01:04:47,520 --> 01:04:49,920
declared statically right so in demos if

1683
01:04:49,920 --> 01:04:51,920
i go here they're declared here

1684
01:04:51,920 --> 01:04:53,280
and so they're basically they're sitting

1685
01:04:53,280 --> 01:04:55,280
somewhere in the kernel and they're all

1686
01:04:55,280 --> 01:04:56,079
car stars

1687
01:04:56,079 --> 01:05:00,000
args arcs or rv is an array of car stars

1688
01:05:00,000 --> 01:05:02,240
and so i imagine that each element

1689
01:05:02,240 --> 01:05:05,760
points to points to

1690
01:05:05,760 --> 01:05:08,240
its own string right so it's an array of

1691
01:05:08,240 --> 01:05:10,640
pointers

1692
01:05:20,839 --> 01:05:23,839
crazy

1693
01:05:24,640 --> 01:05:27,359
i also have a question about this uh the

1694
01:05:27,359 --> 01:05:29,280
dollar three version of

1695
01:05:29,280 --> 01:05:32,480
the array has if i look

1696
01:05:32,480 --> 01:05:35,280
at these addresses the first one is

1697
01:05:35,280 --> 01:05:36,000
suffixed by

1698
01:05:36,000 --> 01:05:39,599
38. second one is suffixed by 40.

1699
01:05:39,599 --> 01:05:43,200
the third one is 48 which is

1700
01:05:43,200 --> 01:05:45,520
not uniform even though the length of

1701
01:05:45,520 --> 01:05:48,000
each of the three arguments

1702
01:05:48,000 --> 01:05:51,119
is three so why why are they different

1703
01:05:51,119 --> 01:05:54,480
uh not in i'm not 100

1704
01:05:54,480 --> 01:05:56,160
certain my guess is that this is an

1705
01:05:56,160 --> 01:05:58,720
attempt to align things

1706
01:05:58,720 --> 01:06:03,440
um right so to get them on a reasonable

1707
01:06:03,440 --> 01:06:06,079
alignment and it is uniform in hex as

1708
01:06:06,079 --> 01:06:08,400
people are pointing out

1709
01:06:08,400 --> 01:06:11,760
oh right yeah yeah that makes sense

1710
01:06:11,760 --> 01:06:14,880
oh oh yes i see it now yeah right

1711
01:06:14,880 --> 01:06:17,039
thanks so you'll sometimes see where

1712
01:06:17,039 --> 01:06:18,160
straight things are

1713
01:06:18,160 --> 01:06:20,319
laid out strangely where there might be

1714
01:06:20,319 --> 01:06:22,400
two things at strange offsets and that's

1715
01:06:22,400 --> 01:06:22,720
just

1716
01:06:22,720 --> 01:06:24,799
because not everything is uh naturally

1717
01:06:24,799 --> 01:06:26,319
the same size

1718
01:06:26,319 --> 01:06:33,839
um okay any other questions

1719
01:06:37,280 --> 01:06:41,119
okay uh we can skip the fifth demo

1720
01:06:41,119 --> 01:06:43,680
and so another useful function that we

1721
01:06:43,680 --> 01:06:44,160
get

1722
01:06:44,160 --> 01:06:47,839
from gdb are

1723
01:06:48,079 --> 01:06:50,400
instead of just break points uh there

1724
01:06:50,400 --> 01:06:52,400
are also watch points and we can also

1725
01:06:52,400 --> 01:06:53,520
set

1726
01:06:53,520 --> 01:06:57,520
conditional break points so

1727
01:06:58,160 --> 01:07:01,839
i'll just briefly go over that

1728
01:07:02,079 --> 01:07:05,680
we run demo six so we can set

1729
01:07:05,680 --> 01:07:08,000
inside this function we can watch so we

1730
01:07:08,000 --> 01:07:09,680
can set a watch point

1731
01:07:09,680 --> 01:07:15,599
um i think here you'll see um

1732
01:07:15,599 --> 01:07:18,319
yeah so here you'll see what uh luca was

1733
01:07:18,319 --> 01:07:20,160
talking about where

1734
01:07:20,160 --> 01:07:22,720
we see that sum has been optimized out

1735
01:07:22,720 --> 01:07:24,480
likely because it's just being

1736
01:07:24,480 --> 01:07:27,599
put in a zero or something we can look

1737
01:07:27,599 --> 01:07:29,359
even at the assembly for this right so

1738
01:07:29,359 --> 01:07:31,359
we can do layout

1739
01:07:31,359 --> 01:07:34,559
splits and yeah indeed we can see that

1740
01:07:34,559 --> 01:07:36,400
it all just being uh

1741
01:07:36,400 --> 01:07:37,920
it's all just being done on the stack it

1742
01:07:37,920 --> 01:07:40,160
looks like to me

1743
01:07:40,160 --> 01:07:41,960
oh no it's all just being done in s0

1744
01:07:41,960 --> 01:07:43,280
s013

1745
01:07:43,280 --> 01:07:46,720
so here you can see that the the

1746
01:07:46,960 --> 01:07:48,799
compiler decided even to use the quality

1747
01:07:48,799 --> 01:07:51,359
saved registers

1748
01:07:51,359 --> 01:07:54,240
and so we can set things like we can do

1749
01:07:54,240 --> 01:07:55,039
watch

1750
01:07:55,039 --> 01:07:58,240
on i

1751
01:07:58,240 --> 01:08:00,240
or we haven't declared i yet because

1752
01:08:00,240 --> 01:08:02,720
we're not inside

1753
01:08:02,720 --> 01:08:06,000
we're not inside the for loop so if we

1754
01:08:06,000 --> 01:08:08,640
step through the c instructions now if

1755
01:08:08,640 --> 01:08:11,440
we do information for the locals we see

1756
01:08:11,440 --> 01:08:12,400
we get i

1757
01:08:12,400 --> 01:08:16,158
we can even watch um watchpoint on

1758
01:08:16,158 --> 01:08:20,479
sum so now anytime that sum changes

1759
01:08:20,479 --> 01:08:23,439
we'll actually get a notification so we

1760
01:08:23,439 --> 01:08:24,799
can continue

1761
01:08:24,799 --> 01:08:27,600
and then we'll get a delete here because

1762
01:08:27,600 --> 01:08:28,000
some

1763
01:08:28,000 --> 01:08:30,560
has been removed so we can't we can't

1764
01:08:30,560 --> 01:08:31,839
actually watch it

1765
01:08:31,839 --> 01:08:35,920
we can even do things like break points

1766
01:08:35,920 --> 01:08:37,759
on sum2 so this is a conditional

1767
01:08:37,759 --> 01:08:39,040
breakpoint

1768
01:08:39,040 --> 01:08:42,238
if well let's actually see what is i

1769
01:08:42,238 --> 01:08:44,640
currently so i is currently one let's

1770
01:08:44,640 --> 01:08:45,279
say

1771
01:08:45,279 --> 01:08:47,600
i think my loop is breaking and whenever

1772
01:08:47,600 --> 01:08:48,799
i is five

1773
01:08:48,799 --> 01:08:50,640
well if i want to specifically debug

1774
01:08:50,640 --> 01:08:53,759
that case i can set a breakpoint

1775
01:08:53,759 --> 01:08:58,560
on sum2

1776
01:08:58,640 --> 01:09:02,799
if i equals five

1777
01:09:02,799 --> 01:09:05,279
so now we have this breakpoint and if we

1778
01:09:05,279 --> 01:09:06,640
continue along

1779
01:09:06,640 --> 01:09:09,679
we'll get to some two and uh we can see

1780
01:09:09,679 --> 01:09:11,520
that it actually printed out

1781
01:09:11,520 --> 01:09:14,158
the first couple values and so we only

1782
01:09:14,158 --> 01:09:15,920
break now on some two

1783
01:09:15,920 --> 01:09:19,520
if if i if we hit that breakpoint

1784
01:09:19,520 --> 01:09:21,198
condition

1785
01:09:21,198 --> 01:09:22,880
and so that's uh this can be again this

1786
01:09:22,880 --> 01:09:24,560
can be useful if you want to debug

1787
01:09:24,560 --> 01:09:26,479
specific edge cases of your code

1788
01:09:26,479 --> 01:09:29,198
and watch points can be useful if for

1789
01:09:29,198 --> 01:09:30,560
instance you think that something

1790
01:09:30,560 --> 01:09:31,839
shouldn't be changing

1791
01:09:31,839 --> 01:09:34,880
but you suspect that it is or you think

1792
01:09:34,880 --> 01:09:36,158
that something is going wrong

1793
01:09:36,158 --> 01:09:39,839
every time you change a certain variable

1794
01:09:39,839 --> 01:09:41,920
and so that's that's uh that's one one

1795
01:09:41,920 --> 01:09:43,600
usage for that

1796
01:09:43,600 --> 01:09:45,520
and uh the last thing i want to talk

1797
01:09:45,520 --> 01:09:48,319
about today is structs

1798
01:09:48,319 --> 01:09:50,080
structs are pretty important and they'll

1799
01:09:50,080 --> 01:09:51,600
come up in

1800
01:09:51,600 --> 01:09:55,040
um in the labs often

1801
01:09:55,040 --> 01:09:58,800
and also so what asks

1802
01:09:58,800 --> 01:10:00,480
i'll talk a little bit about the way

1803
01:10:00,480 --> 01:10:03,600
structs are laid out in memory

1804
01:10:03,600 --> 01:10:06,560
and so a struct is basically um it's a

1805
01:10:06,560 --> 01:10:08,640
continuous contiguous area of memory so

1806
01:10:08,640 --> 01:10:11,440
if we have some struct

1807
01:10:11,440 --> 01:10:14,800
and we have like field one field two

1808
01:10:14,800 --> 01:10:18,159
field three when we make that struck

1809
01:10:18,159 --> 01:10:19,520
those fields are going to be

1810
01:10:19,520 --> 01:10:22,640
aligned next to each other in memories

1811
01:10:22,640 --> 01:10:24,320
and you can kind of think of this

1812
01:10:24,320 --> 01:10:27,120
like an array but f1 f2 and f3 can all

1813
01:10:27,120 --> 01:10:28,480
be different types

1814
01:10:28,480 --> 01:10:31,840
and uh we can uh

1815
01:10:31,840 --> 01:10:33,280
pass them as functions usually they're

1816
01:10:33,280 --> 01:10:34,880
past uh pass them as arguments to

1817
01:10:34,880 --> 01:10:35,840
functions

1818
01:10:35,840 --> 01:10:38,159
usually they're passed by reference so

1819
01:10:38,159 --> 01:10:40,239
here i've made a struct person

1820
01:10:40,239 --> 01:10:44,159
with two integer arguments and

1821
01:10:44,159 --> 01:10:46,560
i'm passing them passing a person as an

1822
01:10:46,560 --> 01:10:48,320
argument to print person

1823
01:10:48,320 --> 01:10:51,120
and uh printing out some of that

1824
01:10:51,120 --> 01:10:52,159
information

1825
01:10:52,159 --> 01:10:54,880
so if we hop into gdb and let's delete

1826
01:10:54,880 --> 01:10:57,040
all of our breakpoints and watch points

1827
01:10:57,040 --> 01:11:00,320
and now we can set a breakpoint at

1828
01:11:00,320 --> 01:11:04,159
person and let's continue

1829
01:11:04,159 --> 01:11:07,600
and run seventh demo

1830
01:11:07,600 --> 01:11:09,280
we can see that now we're here and so if

1831
01:11:09,280 --> 01:11:11,040
we type iframe

1832
01:11:11,040 --> 01:11:15,360
we can see that we have an argument p

1833
01:11:15,360 --> 01:11:18,880
and indeed we can if we do print

1834
01:11:18,880 --> 01:11:22,719
p if we can even tell that it's a struct

1835
01:11:22,719 --> 01:11:23,520
person

1836
01:11:23,520 --> 01:11:26,880
at this address and

1837
01:11:26,880 --> 01:11:30,239
we can if we dereference it

1838
01:11:30,239 --> 01:11:32,560
gdb will tell us exactly what p looks

1839
01:11:32,560 --> 01:11:35,280
like it has id 1215

1840
01:11:35,280 --> 01:11:39,120
age is 22 and just to show kind of how

1841
01:11:39,120 --> 01:11:40,640
things are

1842
01:11:40,640 --> 01:11:43,760
laid out we can take this address

1843
01:11:43,760 --> 01:11:48,400
and we do x hd at this

1844
01:11:53,679 --> 01:11:56,719
i address exactly

1845
01:12:02,159 --> 01:12:04,320
so if we again so we can use this to

1846
01:12:04,320 --> 01:12:05,280
debug

1847
01:12:05,280 --> 01:12:08,719
our structures in

1848
01:12:08,719 --> 01:12:11,920
in the code we can take a look at what's

1849
01:12:11,920 --> 01:12:13,760
going on

1850
01:12:13,760 --> 01:12:16,880
with structures this way so gdb is a

1851
01:12:16,880 --> 01:12:18,080
super powerful tool

1852
01:12:18,080 --> 01:12:20,239
not just for you know stepping through

1853
01:12:20,239 --> 01:12:22,800
code but also for examining

1854
01:12:22,800 --> 01:12:26,239
all kinds of potentially problematic

1855
01:12:26,239 --> 01:12:28,159
pieces in your code and looking at

1856
01:12:28,159 --> 01:12:30,000
arguments and stack frames and things

1857
01:12:30,000 --> 01:12:30,880
like that

1858
01:12:30,880 --> 01:12:32,480
and this will be hopefully will be

1859
01:12:32,480 --> 01:12:35,360
useful in the next lab

1860
01:12:35,360 --> 01:12:38,000
when you have to work with um with stack

1861
01:12:38,000 --> 01:12:40,080
frames and with assembly code

1862
01:12:40,080 --> 01:12:42,719
so that's that's mostly what i wanted to

1863
01:12:42,719 --> 01:12:44,080
talk about today so

1864
01:12:44,080 --> 01:12:47,360
with the last kind of seven minutes of

1865
01:12:47,360 --> 01:12:47,920
lecture

1866
01:12:47,920 --> 01:12:50,560
i'll open it up to any any other

1867
01:12:50,560 --> 01:12:53,600
questions that you guys have

1868
01:12:59,360 --> 01:13:02,800
i had a bit of a tangential question who

1869
01:13:02,800 --> 01:13:05,120
is in who manages the the creation of

1870
01:13:05,120 --> 01:13:05,920
compilers

1871
01:13:05,920 --> 01:13:08,719
from like to get from c to various uh

1872
01:13:08,719 --> 01:13:10,239
instruction set architectures is that

1873
01:13:10,239 --> 01:13:11,920
the creator of the instruction set

1874
01:13:11,920 --> 01:13:13,280
architecture is it a third party

1875
01:13:13,280 --> 01:13:14,560
something like that

1876
01:13:14,560 --> 01:13:18,080
um i believe that it is

1877
01:13:18,080 --> 01:13:19,920
not the creator of the instruction set

1878
01:13:19,920 --> 01:13:22,320
so it's often a third party

1879
01:13:22,320 --> 01:13:24,159
so the two big c compilers that you'll

1880
01:13:24,159 --> 01:13:26,239
see refer to are gcc

1881
01:13:26,239 --> 01:13:28,640
which is maintained by i think the gnu

1882
01:13:28,640 --> 01:13:30,000
foundation

1883
01:13:30,000 --> 01:13:33,440
and uh c lang or llvm

1884
01:13:33,440 --> 01:13:36,080
which is its own thing so i think you

1885
01:13:36,080 --> 01:13:37,280
know you can find

1886
01:13:37,280 --> 01:13:39,679
i believe lovm is even open source so

1887
01:13:39,679 --> 01:13:40,960
you can find

1888
01:13:40,960 --> 01:13:43,120
um you can you can find the code

1889
01:13:43,120 --> 01:13:44,560
specifically that does this

1890
01:13:44,560 --> 01:13:46,800
uh when a new instruction set is

1891
01:13:46,800 --> 01:13:48,800
released such as risk five

1892
01:13:48,800 --> 01:13:50,880
that calling convention document as well

1893
01:13:50,880 --> 01:13:53,360
as all of those instruction documents

1894
01:13:53,360 --> 01:13:54,960
uh i think you're careful but i assume

1895
01:13:54,960 --> 01:13:56,800
there's like a high level of cooperation

1896
01:13:56,800 --> 01:13:58,480
between the compiler designer and the

1897
01:13:58,480 --> 01:14:00,239
instruction set designer

1898
01:14:00,239 --> 01:14:03,760
um but yeah short answer is i i believe

1899
01:14:03,760 --> 01:14:04,560
it's a third

1900
01:14:04,560 --> 01:14:07,120
third party who does it likely with a

1901
01:14:07,120 --> 01:14:08,719
lot of cooperation from the people who

1902
01:14:08,719 --> 01:14:09,840
make the instruction set

1903
01:14:09,840 --> 01:14:12,719
risk five is probably risk five might be

1904
01:14:12,719 --> 01:14:14,880
an exception where because it came out

1905
01:14:14,880 --> 01:14:16,560
of a research project

1906
01:14:16,560 --> 01:14:18,560
they may have written the the compiler

1907
01:14:18,560 --> 01:14:20,159
for it themselves

1908
01:14:20,159 --> 01:14:23,280
as well i i don't think intel has

1909
01:14:23,280 --> 01:14:26,880
for example has input in uh in gcc or

1910
01:14:26,880 --> 01:14:29,840
llvm

1911
01:14:45,520 --> 01:14:48,239
other questions

1912
01:14:54,640 --> 01:14:57,840
okay well uh thanks

1913
01:14:57,840 --> 01:14:59,920
for listening in that case and i guess

1914
01:14:59,920 --> 01:15:01,760
嗯

1915
01:15:01,760 --> 01:15:04,880
这节课就讲到这里

1916
01:15:04,880 --> 01:15:06,480
剩余的五分钟

1917
01:15:06,480 --> 01:15:09,520
留给大家好好休息

